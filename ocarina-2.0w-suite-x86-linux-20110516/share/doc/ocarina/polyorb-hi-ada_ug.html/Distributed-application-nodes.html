<html lang="en">
<head>
<title>Distributed application nodes - PolyORB-HI User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="PolyORB-HI User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="AADL-to-Ada-transformations.html#AADL-to-Ada-transformations" title="AADL to Ada transformations">
<link rel="prev" href="Whole-distributed-application.html#Whole-distributed-application" title="Whole distributed application">
<link rel="next" href="Nodes.html#Nodes" title="Nodes">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2006-2009 E'cole nationale supe'rieure
des te'le'communications

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU Free Documentation License'', with the
Front-Cover Texts being ``PolyORB High Integrity User's Guide'', and
with no Back-Cover Texts.  A copy of the license is included in the
section entitled ``GNU Free Documentation License''.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
body {}
body {
	background-color: white;
	position: absolute;
	font-size: medium;
	font-family: Verdana;
//	padding-left: 7em;
	top: 3em;
}

div.navigation {
	font-size: small; 
	padding-left: 0; 
	padding-right: 0; 
	text-align: right
}

div#menu {
	text-align: left;
	position: fixed;
	left: 1pt;
	bottom: auto;
	top: 2em;
	right: auto;
	padding-right: 1ex;
	padding-left: 1em;
	padding-top: 1ex;
	padding-bottom: 1ex;
	border-width: 3pt;
	background-color: transparent;  
	border-color: red; 
	border-left-style: solid
}

div#menu span.item {
	display: block;
	background-color: transparent;  
}

table.navigation {
	font-size: small
} 


/* Paragraphs */
p, blockquote {
	color: black; 
	text-indent: 1em; 
	text-align: justify
}


p {
	margin-bottom: .5em; 
	margin-top: 1px
}

p kbd 
{
  background-color: ivory
}

div.important {
	background-color: lightgray; 
	border-color: red; 
	border-style: solid;  
	border-width: 1pt
}
p.important {
	color: red
}
p.brut {
	text-indent: 0
}
p.brut:first-letter {
	font-size: 100%; 
	font-weight: normal
}

/* Sections */
div {
	border-style: none; 
	padding-left: 1em; 
	padding-right: 1em; 
	margin-top: 2px; 
	margin-bottom: 2px
}


/* Menus */

div.action {
	background-color: ivory; 
	border-color: lightgray; 
	border-style: solid; 
	border-width: 1pt 1pt 1pt 1pt; 
	font-size: small; 
	text-align: left
}

div.special 
{
  border-color: lightgray; 
  border-style: solid; 
  border-width: 0 0 0 4pt
}


/* Docbook special settings */

h3.subtitle {
	text-align: center
}

h1.title {
	margin-bottom: 10pt;
}

div.authorgroup {
	margin-top: 2em;
	margin-bottom: 2em;
	text-align: center;
	display: block;
}

div.author {
	display: inline;
}

h3.author {
	display: inline;
	font-style: normal;
	color: black;
	font-size: medium;
}

p.copyright {
	margin-top: 1em;
	text-align: center;
}

/* End docbook settings */


/* hors-texte */

pre {
	background-color: whitesmoke;
	border-color: lightcoral;
	border-style: solid;
	border-width: 0pt 1pt 1pt 0pt;
}

.hors-texte {
	background-color: lightgray;  
	border-color: lightcoral; 
	border-style: solid;
	border-width: 1pt; 
	padding-left: 1em; 	
	padding-right: 1em; 
	text-align: justify
}

/* Tables */

table.hors-texte {
	margin: auto; 
	font-size: 100%;
	border-width: 1pt 1pt 1pt 1pt
}

table.hors-texte td {
	padding-left: 1ex; 
	padding-right: 1ex
}

table.hors-texte tr.sep {
	padding-top: 1ex
}


h1, h2, h3, h4, h5, h6 
{
  color: black; 
  text-decoration: none; 
  font-weight: bold;
  padding: 0pt
}

h1 {
	font-size: larger larger larger;
	text-align: center; 
	margin-bottom: 24pt
}
h2 {
	font-size: larger larger;
	margin-left:      0; 
	margin-top:       24pt; 
	margin-bottom:    14pt;
	border-color:     red;
	border-bottom-style:     solid;
	border-width:     1pt;
	padding:          2pt; 
	margin-left:      0; 
	margin-right:     0; 
}
h3 {
	font-size: larger;
	margin-left: 1em; 
	margin-bottom: 1ex;
	color: red;	
}
h4, h5, h6 {
	font-size: normal;
	margin-left: 2em; 
	margin-bottom: 1em
}

h4 {
	text-decoration: underlined
}
h5 {
	font-style: italic
}


h2.special 
{
  border-style:     solid;
  border-width:	    1pt;
  border-color:     lightgray;
  padding:          2pt; 
}

img.flottant {
	float: right;
	clear: both;
	margin: 2em;
}

/* Lists */

li, dd 
{
  text-align: justify
}

dt {
	font-style: normal; 
	margin-top: 1em
}
dd {
	font-style: normal; 
	margin-left: 4em
}

dd.sdd {
	margin-left: 5em
}

dd ul {margin-top: 0}
li dl {margin-top: 0}
ul {list-style-type: square}
ul ul {list-style-type: disc}
ul ul ul {list-style-type: circle}

/* Addresses */

address {
	margin-top: 1ex; margin-bottom: 1ex
}
address.poste {
	font-style: italic
}
address.email {
	font-style: normal
}
address.phone {
	font-style: oblic
}

/* Links */

a:link, a:visited {
	color: darkred;
	text-decoration: none;
	border-bottom-width: 1px;
	border-bottom-style: dotted;
	border-bottom-color:  red;
	padding-bottom: 0px
}

a:hover, a:active {
	color: red; 
	text-decoration: none;
	border-bottom-color: black;
	border-bottom-style: solid
}

--></style>
</head>
<body>
<div class="node">
<p>
<a name="Distributed-application-nodes"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Nodes.html#Nodes">Nodes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Whole-distributed-application.html#Whole-distributed-application">Whole distributed application</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="AADL-to-Ada-transformations.html#AADL-to-Ada-transformations">AADL to Ada transformations</a>
<hr>
</div>

<h3 class="section">B.2 Distributed application nodes (processes)</h3>

<!--  -->
<p>In this section, we give the AADL entities used to model a node of
distributed application. Then, we give the rules applied to map Ada
code from these AADL entities. Only rules that are related directly to
a node as a whole subsystem are listed here. The rules that are
specific to the sub-components of a node are explained in the sections
that deal with these respective sub-components.

<h4 class="subsection">B.2.1 AADL entities</h4>

<p>To model a distributed application node in AADL we use the
<code>process</code> component. The process implementation shown in the
listing below shows such system. For each node of the
distributed application, we add a process instantiation as
subcomponent in the system implementation that models the distributed
application.

<pre class="smallexample">     
     <b>package</b> PING_Package
     <b>public</b>
       <b>process</b> <b>implementation</b> A.Impl
       <b>subcomponents</b>
         Pinger : <b>thread</b> Software::P.Impl;
       <b>connections</b>
         <b>port</b> Pinger.Data_Source -&gt; Out_Port;
       <b>end</b> A.Impl;
     <b>end</b> PING_Package;
     
</pre>
   <p>For each thread that belongs to a node of the distributed application,
we instantiate a subcomponent in the process implementation. For each
connection between a node and another, a <code>port</code> feature has to be
added to both nodes with the direction <code>out</code> for the source and
<code>in</code> for the destination (see <a href="Connections.html#Connections">Connections</a> for more details
on connections mapping).

<h4 class="subsection">B.2.2 Ada mapping rules</h4>

<p>All the Ada entities mapped from a distributed application node, are
created in a child directory of the directory mapped from the
distributed application. This directory has the same name as the
process <em>subcomponent</em> instance relative to the handled node in
the system implementation that model the distributed application, in
lower case.

   <p>For example, all the entities relative to <code>Node_A</code>, an instance
of the process <code>A</code> of the <code>Ping</code> example are generated in
the directory <code>ping_impl/node_a</code>.

   <p>The following paragraphs list the Ada compilation units that are
created for each node of the distributed application.

<h5 class="subsubsection">B.2.2.1 Data marshallers</h5>

<p>The data marshallers are generated in a package called
<code>PolyORB_HI_Generated.Marshallers</code>. This package provides
routines to convert the data types used in the node and other useful
generated type to a representation suitable for transmission over
network.

<pre class="smallexample">     
     --------------------------------------------------------
     -- <i> This file was automatically generated by Ocarina  --</i>
     -- <i> Do NOT hand-modify this file, as your             --</i>
     -- <i> changes will be lost when you re-run Ocarina      --</i>
     --------------------------------------------------------
     <b>pragma</b> Style_Checks
      ("<i>NM32766</i>");
     <b>with</b> PolyORB_HI_Generated.Activity;
     <b>with</b> PolyORB_HI.Messages;
     <b>with</b> PolyORB_HI_Generated.Types;
     
     <b>package</b> PolyORB_HI_Generated.Marshallers <b>is</b>
     
       -- <i> Marshallers for interface type of thread p.impl</i>
     
       <b>procedure</b> Marshall
        (Data : PolyORB_HI_Generated.Activity.Software_P_Impl_Interface;
         Message : <b>in</b> <b>out</b> PolyORB_HI.Messages.Message_Type);
     
       <b>procedure</b> Unmarshall
        (Port : PolyORB_HI_Generated.Activity.Software_P_Impl_Port_Type;
         Data : <b>out</b> PolyORB_HI_Generated.Activity.Software_P_Impl_Interface;
         Message : <b>in</b> <b>out</b> PolyORB_HI.Messages.Message_Type);
     
       -- <i> Marshallers for DATA type simple_type</i>
     
       <b>procedure</b> Marshall
        (Data : PolyORB_HI_Generated.Types.Simple_Type;
         Message : <b>in</b> <b>out</b> PolyORB_HI.Messages.Message_Type);
     
       <b>procedure</b> Unmarshall
        (Data : <b>out</b> PolyORB_HI_Generated.Types.Simple_Type;
         Message : <b>in</b> <b>out</b> PolyORB_HI.Messages.Message_Type);
     
     <b>end</b> PolyORB_HI_Generated.Marshallers;
     
</pre>
   <p>The body of <code>PolyORB_HI_Generated.Marshallers</code> instantiates of
the generic package <code>PolyORB_HI.Marshallers_G</code> for the
corresponding types. The generic package
<code>PolyORB_HI.Marshallers_G</code> is part of PolyORB-HI-Ada
components. The example above shows the specification of the generated
<code>PolyORB_HI_Generated.Marshallers</code> mapped from the <code>Node_A</code>
node of the <code>Ping</code>.

<h5 class="subsubsection">B.2.2.2 Node activity</h5>

<p>We denote &ldquo;activity&rdquo; the set of the actions performed by one
particular node. This denotes particularly the periodic, sporadic and
hybrid threads that belongs to this node.

   <p>The code related to the node activity is generated in an Ada package
called <code>PolyORB_HI_Generated.Activity</code> as shown in the following
example:

<pre class="smallexample">     
     --------------------------------------------------------
     -- <i> This file was automatically generated by Ocarina  --</i>
     -- <i> Do NOT hand-modify this file, as your             --</i>
     -- <i> changes will be lost when you re-run Ocarina      --</i>
     --------------------------------------------------------
     <b>pragma</b> Style_Checks
      ("<i>NM32766</i>");
     <b>with</b> PolyORB_HI_Generated.Types;
     <b>with</b> PolyORB_HI.Errors;
     <b>with</b> PolyORB_HI_Generated.Deployment;
     <b>with</b> Ada.Real_Time;
     <b>with</b> System;
     <b>with</b> PolyORB_HI.Periodic_Task;
     
     <b>package</b> PolyORB_HI_Generated.Activity <b>is</b>
     
       -- <i> BEGIN: Entities used by all instances of component P.Impl</i>
     
       <b>type</b> Software_P_Impl_Port_Type <b>is</b>
        (Data_Source);
     
       <b>type</b> Software_P_Impl_Interface
        (Port : Software_P_Impl_Port_Type := Software_P_Impl_Port_Type'First)
       <b>is</b>
         <b>record</b>
           <b>case</b> Port <b>is</b>
             <b>when</b> Data_Source =&gt;
               Data_Source_DATA : PolyORB_HI_Generated.Types.Simple_Type;
             <b>pragma</b> Warnings (Off);
             <b>when</b> <b>others</b> =&gt;
               <b>null</b>;
             <b>pragma</b> Warnings (On);
           <b>end</b> <b>case</b>;
         <b>end</b> <b>record</b>;
     
       <b>function</b> Send_Output
        (Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Port : Software_P_Impl_Port_Type)
        <b>return</b> PolyORB_HI.Errors.Error_Kind;
     
       <b>procedure</b> Put_Value
        (Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Thread_Interface : Software_P_Impl_Interface);
     
       <b>procedure</b> Receive_Input
        (Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Port : Software_P_Impl_Port_Type);
     
       <b>function</b> Get_Value
        (Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Port : Software_P_Impl_Port_Type)
        <b>return</b> Software_P_Impl_Interface;
     
       <b>function</b> Get_Sender
        (Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Port : Software_P_Impl_Port_Type)
        <b>return</b> PolyORB_HI_Generated.Deployment.Entity_Type;
     
       <b>function</b> Get_Count
        (Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Port : Software_P_Impl_Port_Type)
        <b>return</b> Standard.Integer;
     
       <b>function</b> Get_Time_Stamp
        (Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Port : Software_P_Impl_Port_Type)
        <b>return</b> Ada.Real_Time.Time;
     
       <b>procedure</b> Next_Value
        (Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Port : Software_P_Impl_Port_Type);
     
       <b>procedure</b> Store_Received_Message
        (Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Thread_Interface : Software_P_Impl_Interface;
         From : PolyORB_HI_Generated.Deployment.Entity_Type;
         Time_Stamp : Ada.Real_Time.Time :=
           Ada.Real_Time.Clock);
     
       <b>procedure</b> Wait_For_Incoming_Events
        (Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Port : <b>out</b> Software_P_Impl_Port_Type);
     
       -- <i> END: Entities used by all instances of component P.Impl</i>
     
       -- <i> Periodic task : Pinger</i>
     
       <b>function</b> PING_Package_Pinger_Job <b>return</b> PolyORB_HI.Errors.Error_Kind;
     
       <b>procedure</b> PING_Package_Pinger_Init;
     
       <b>procedure</b> PING_Package_Pinger_Recover;
     
       <b>package</b> PING_Package_Pinger_Task <b>is</b>
        <b>new</b> PolyORB_HI.Periodic_Task
          (Entity =&gt; PolyORB_HI_Generated.Deployment.Node_A_Pinger_K,
           Task_Period =&gt; Ada.Real_Time.Milliseconds
            (1000),
           Task_Deadline =&gt; Ada.Real_Time.Milliseconds
            (1000),
           Task_Priority =&gt; (System.Priority'First
             + (((2
               - 0)
               * (System.Priority'Last
                 - System.Priority'First))
               / 255)),
           Task_Stack_Size =&gt; 100000,
           Job =&gt; PING_Package_Pinger_Job,
           Initialize_Entrypoint =&gt; PING_Package_Pinger_Init,
           Recover_Entrypoint =&gt; PING_Package_Pinger_Recover);
     
     <b>end</b> PolyORB_HI_Generated.Activity;
     
</pre>
   <p>All the naming rules explained in <a href="Whole-distributed-application.html#Whole-distributed-application">Whole distributed application</a>
are also applied to map the package name. The
<code>PolyORB_HI_Generated.Activity</code> package contains all the routines
mapped from the threads that belong to the handled node. This package
contains also the instances of shared objects used in this node. 
See <a href="Threads.html#Threads">Threads</a>.

<h5 class="subsubsection">B.2.2.3 Data types</h5>

<p>All the data types mapped from AADL data components and used by a
particular node of a distributed application are gathered in a
separate Ada package called <code>PolyORB_HI_Generated.Types</code>. The
name of this package is fixed for the sake of simplicity because it
may be used by the user implementation code. The user does not have to
change his implementation code if he renamed its distributed
application.

<pre class="smallexample">     
     --------------------------------------------------------
     -- <i> This file was automatically generated by Ocarina  --</i>
     -- <i> Do NOT hand-modify this file, as your             --</i>
     -- <i> changes will be lost when you re-run Ocarina      --</i>
     --------------------------------------------------------
     <b>pragma</b> Style_Checks
      ("<i>NM32766</i>");
     <b>with</b> User_Types;
     
     <b>package</b> PolyORB_HI_Generated.Types <b>is</b>
     
       <b>type</b> Simple_Type <b>is</b>
        <b>new</b> Standard.Integer;
     
       -- <i> simple_type'Object_Size ~= 32 bits</i>
     
       Simple_Type_Default_Value : Simple_Type :=
        0;
     
       <b>type</b> Opaque_Type <b>is</b>
        <b>new</b> User_Types.The_Opaque_Type;
     
       -- <i> opaque_type'Object_Size ~= 0 bits</i>
     
       Opaque_Type_Default_Value : Opaque_Type;
     
     <b>end</b> PolyORB_HI_Generated.Types;
     
</pre>
   <h5 class="subsubsection">B.2.2.4 Subprograms</h5>

<p>The mapping of all AADL subprogram components used by a particular
node is generated in a separate Ada package. The name of this package
is <code>PolyORB_HI_Generated.Subprograms</code> as shown in the following
example:

<pre class="smallexample">     
     --------------------------------------------------------
     -- <i> This file was automatically generated by Ocarina  --</i>
     -- <i> Do NOT hand-modify this file, as your             --</i>
     -- <i> changes will be lost when you re-run Ocarina      --</i>
     --------------------------------------------------------
     <b>pragma</b> Style_Checks
      ("<i>NM32766</i>");
     <b>with</b> PolyORB_HI_Generated.Types;
     
     <b>package</b> PolyORB_HI_Generated.Subprograms <b>is</b>
     
       <b>procedure</b> Software_P_Wrapper_Impl
        (Data_Source : <b>out</b> PolyORB_HI_Generated.Types.Simple_Type);
     
       <b>procedure</b> Software_Do_Ping_Spg_Impl
        (Data_Source : <b>out</b> PolyORB_HI_Generated.Types.Opaque_Type);
     
       <b>procedure</b> Software_Do_Convert_Spg_Impl
        (Data_Sink : PolyORB_HI_Generated.Types.Opaque_Type;
         Data_Source : <b>out</b> PolyORB_HI_Generated.Types.Simple_Type);
     
     <b>end</b> PolyORB_HI_Generated.Subprograms;
     
</pre>
   <h5 class="subsubsection">B.2.2.5 Deployment information</h5>

<p>The deployment information is the information each node has on the
other nodes of the distributed applications. This information is used,
in conjunction with the naming table (see the next paragraph) to allow
a node to send a request to another node or to receive a request from
another node. The deployment information is generated for each node in
the package <code>PolyORB_HI_Generated.Deployment</code>.

   <p>The <code>PolyORB_HI_Generated.Deployment</code> package contains several
Ada enumeration types:

     <ul>
<li><code>Node_Type</code>. For each node in the application accessible from the
current node, we create an enumeration literal whose name is mapped
from the node &ldquo;instance&rdquo; declared in the system implementation to
which we concatenate the string &ldquo;_K&rdquo;. All the naming rules listed in
<a href="Whole-distributed-application.html#Whole-distributed-application">Whole distributed application</a> have to be respected.

     <p>In addition, the constant <code>My_Node</code> of type <code>Node_Type</code> is
defined and store the value of the current node.

     <li><code>Entity_Type</code>. For each thread in the application that belongs to
the current node or that is connected (via its owner process) to one
of the threads of the current node, we declare an enumeration
literal. The defining identifier of the enumerator is mapped from the
process subcomponent name and the thread subcomponent name as follows:
<code>&lt;Node_Name&gt;_&lt;Thread_Name&gt;_K</code>. All the naming rules listed in
<a href="Whole-distributed-application.html#Whole-distributed-application">Whole distributed application</a> must be respected.

     <li><code>Port_Type</code>. For each thread port in the distributed applications
accessible from the current node, we declare an enumeration
literal. Only threads that belongs to the <code>Entity_Type</code>
enumeration are mapped. 
</ul>

   <p>For each table, Ada enumeration clauses are generated to guarantee
that each enumeration literal has a unique value across partitions.

   <p>The table called <code>Entity_Table</code> is generated to map threads to nodes,
and <code>Port_Table</code> to maps port to threads.

   <p>Finally, we generate a constant (<code>Max_Payload_Size</code>) that
indicates the maximal size (in bits) of a message handled in the
current node. This size is computed automatically from the set of data
types handled (sent or received) in the node. It will be used to
configure the <code>PolyORB_HI.Messages</code> package.

   <p>The following example shows the <code>PolyORB_HI_Generated.Deployment</code>
package relative to the node <code>Node_A</code> of the <code>Ping</code> example:

<pre class="smallexample">     
     --------------------------------------------------------
     -- <i> This file was automatically generated by Ocarina  --</i>
     -- <i> Do NOT hand-modify this file, as your             --</i>
     -- <i> changes will be lost when you re-run Ocarina      --</i>
     --------------------------------------------------------
     <b>pragma</b> Style_Checks
      ("<i>NM32766</i>");
     
     <b>package</b> PolyORB_HI_Generated.Deployment <b>is</b>
     
       <b>pragma</b> Preelaborate;
     
       -- <i> For each node in the distributed application add an enumerator</i>
     
       <b>type</b> Node_Type <b>is</b>
        (Node_A_K,
         Node_B_K);
     
       -- <i> Representation clause to have consistent positions for enumerators</i>
     
       <b>for</b> Node_Type <b>use</b>
        (Node_A_K =&gt;
          1,
         Node_B_K =&gt;
          2);
     
       -- <i> Size of Node_Type fixed to 8 bits</i>
     
       <b>for</b> Node_Type'Size <b>use</b> 8;
     
       Max_Node_Image_Size : <b>constant</b> Standard.Integer :=
        8;
     
       -- <i> Maximal Node_Image size for this node</i>
     
       -- <i> Node Image</i>
     
       <b>subtype</b> UT_Deployment_Node_A_Node_Type_Range <b>is</b>
        Node_Type <b>range</b> Node_Type'First .. Node_Type'Last;
     
       <b>subtype</b> UT_Deployment_Node_A_1_Max_Node_Image_Size <b>is</b>
        Integer <b>range</b> 1 .. Max_Node_Image_Size;
     
       <b>subtype</b> UT_Deployment_Node_A_Node_Image_Component <b>is</b>
        Standard.String
          (UT_Deployment_Node_A_1_Max_Node_Image_Size);
     
       <b>type</b> UT_Deployment_Node_A_Node_Image_Array <b>is</b>
        <b>array</b> (UT_Deployment_Node_A_Node_Type_Range)
          <b>of</b> UT_Deployment_Node_A_Node_Image_Component;
     
       Node_Image : <b>constant</b> UT_Deployment_Node_A_Node_Image_Array :=
        UT_Deployment_Node_A_Node_Image_Array'
          (Node_A_K =&gt;
            "<i>Node_A_K</i>",
           Node_B_K =&gt;
            "<i>Node_B_K</i>");
     
       My_Node : <b>constant</b> Node_Type :=
        Node_A_K;
     
       -- <i> For each thread in the distributed application nodes, add an enumerator</i>
     
       <b>type</b> Entity_Type <b>is</b>
        (Node_A_Pinger_K,
         Node_B_Ping_Me_K);
     
       -- <i> Representation clause to have consistent positions for enumerators</i>
     
       <b>for</b> Entity_Type <b>use</b>
        (Node_A_Pinger_K =&gt;
          1,
         Node_B_Ping_Me_K =&gt;
          2);
     
       -- <i> Size of Entity_Type fixed to 8 bits</i>
     
       <b>for</b> Entity_Type'Size <b>use</b> 8;
     
       -- <i> Entity Table</i>
     
       <b>subtype</b> UT_Deployment_Node_A_Entity_Type_Range <b>is</b>
        Entity_Type <b>range</b> Entity_Type'First .. Entity_Type'Last;
     
       <b>type</b> UT_Deployment_Node_A_Entity_Table_Array <b>is</b>
        <b>array</b> (UT_Deployment_Node_A_Entity_Type_Range)
          <b>of</b> Node_Type;
     
       Entity_Table : <b>constant</b> UT_Deployment_Node_A_Entity_Table_Array :=
        UT_Deployment_Node_A_Entity_Table_Array'
          (Node_A_Pinger_K =&gt;
            Node_A_K,
           Node_B_Ping_Me_K =&gt;
            Node_B_K);
     
       Max_Entity_Image_Size : <b>constant</b> Standard.Integer :=
        16;
     
       -- <i> Maximal Entity_Image size for this node</i>
     
       -- <i> Entity Image</i>
     
       <b>subtype</b> UT_Deployment_Node_A_1_Max_Entity_Image_Size <b>is</b>
        Integer <b>range</b> 1 .. Max_Entity_Image_Size;
     
       <b>subtype</b> UT_Deployment_Node_A_Entity_Image_Component <b>is</b>
        Standard.String
          (UT_Deployment_Node_A_1_Max_Entity_Image_Size);
     
       <b>type</b> UT_Deployment_Node_A_Entity_Image_Array <b>is</b>
        <b>array</b> (UT_Deployment_Node_A_Entity_Type_Range)
          <b>of</b> UT_Deployment_Node_A_Entity_Image_Component;
     
       Entity_Image : <b>constant</b> UT_Deployment_Node_A_Entity_Image_Array :=
        UT_Deployment_Node_A_Entity_Image_Array'
          (Node_A_Pinger_K =&gt;
            "<i>Node_A_Pinger_K </i>",
           Node_B_Ping_Me_K =&gt;
            "<i>Node_B_Ping_Me_K</i>");
     
       -- <i> For each thread port in the distributed application nodes, add an </i>
       -- <i> enumerator</i>
     
       <b>type</b> Port_Type <b>is</b>
        (Node_A_Pinger_Data_Source_K,
         Node_B_Ping_Me_Data_Sink_K);
     
       -- <i> Representation clause to have consistent positions for enumerators</i>
     
       <b>for</b> Port_Type <b>use</b>
        (Node_A_Pinger_Data_Source_K =&gt;
          1,
         Node_B_Ping_Me_Data_Sink_K =&gt;
          2);
     
       -- <i> Size of Port_Type fixed to 16 bits</i>
     
       <b>for</b> Port_Type'Size <b>use</b> 16;
     
       -- <i> Port Table</i>
     
       <b>subtype</b> UT_Deployment_Node_A_Port_Type_Range <b>is</b>
        Port_Type <b>range</b> Port_Type'First .. Port_Type'Last;
     
       <b>type</b> UT_Deployment_Node_A_Port_Table_Array <b>is</b>
        <b>array</b> (UT_Deployment_Node_A_Port_Type_Range)
          <b>of</b> Entity_Type;
     
       Port_Table : <b>constant</b> UT_Deployment_Node_A_Port_Table_Array :=
        UT_Deployment_Node_A_Port_Table_Array'
          (Node_A_Pinger_Data_Source_K =&gt;
            Node_A_Pinger_K,
           Node_B_Ping_Me_Data_Sink_K =&gt;
            Node_B_Ping_Me_K);
     
       Max_Port_Image_Size : <b>constant</b> Standard.Integer :=
        27;
     
       -- <i> Maximal Port_Image size for this node</i>
     
       <b>subtype</b> Port_Sized_String <b>is</b>
        Standard.String
          (1 .. PolyORB_HI_Generated.Deployment.Max_Port_Image_Size);
     
       -- <i> Port Image</i>
     
       <b>type</b> UT_Deployment_Node_A_Port_Image_Array <b>is</b>
        <b>array</b> (UT_Deployment_Node_A_Port_Type_Range)
          <b>of</b> Port_Sized_String;
     
       Port_Image : <b>constant</b> UT_Deployment_Node_A_Port_Image_Array :=
        UT_Deployment_Node_A_Port_Image_Array'
          (Node_A_Pinger_Data_Source_K =&gt;
            "<i>Node_A_Pinger_Data_Source_K</i>",
           Node_B_Ping_Me_Data_Sink_K =&gt;
            "<i>Node_B_Ping_Me_Data_Sink_K </i>");
     
       -- <i> Maximal message payload size for this node (in bits)</i>
     
       Max_Payload_Size : <b>constant</b> Standard.Integer :=
        112;
     
       -- <i> Biggest type: simple_type</i>
     
     <b>end</b> PolyORB_HI_Generated.Deployment;
     
</pre>
   <h5 class="subsubsection">B.2.2.6 Naming information</h5>

<p>The naming information for a particular node allows this node to send
requests to another node in the distributed application and to receive
a request from another node. It contains for each node, the
information necessary to establish a connection with a remote
node. These information are deduced statically from the AADL model.

   <p>The naming information is generated in a package called
<code>PolyORB_HI_Generated.Naming</code>.

<pre class="smallexample">     
     --------------------------------------------------------
     -- <i> This file was automatically generated by Ocarina  --</i>
     -- <i> Do NOT hand-modify this file, as your             --</i>
     -- <i> changes will be lost when you re-run Ocarina      --</i>
     --------------------------------------------------------
     <b>pragma</b> Style_Checks
      ("<i>NM32766</i>");
     <b>with</b> PolyORB_HI.Utils;
     <b>with</b> PolyORB_HI_Generated.Deployment;
     
     <b>package</b> PolyORB_HI_Generated.Naming <b>is</b>
     
       -- <i> Naming Table for bus the_bus</i>
     
       Naming_Table : <b>constant</b> PolyORB_HI.Utils.Naming_Table_Type :=
        (PolyORB_HI_Generated.Deployment.Node_A_K =&gt;
          (PolyORB_HI.Utils.To_Hi_String
            ("<i>127.0.0.1</i>"),
           0),
         PolyORB_HI_Generated.Deployment.Node_B_K =&gt;
          (PolyORB_HI.Utils.To_Hi_String
            ("<i>127.0.0.1</i>"),
           12002));
     
     <b>end</b> PolyORB_HI_Generated.Naming;
     
</pre>
   <p>As shown in the example above, for the node <code>Node_A</code> of the
<code>Ping</code> example, the <code>PolyORB_HI_Generated.Naming</code> package
contains:
     <ul>
  <li>A static table called <code>Naming_Table</code> indexed by means of
  the <code>Node_Type</code> declared in the
  <code>PolyORB_HI_Generated.Deployment</code> package. This table contains,
  for each node of the distributed application, all the information
  necessary to establish a connection with this node. 
</ul>

<h5 class="subsubsection">B.2.2.7 Transport Layer</h5>

<p>The transport high-level layer is generated automatically for each
node of the application in a package called
<code>PolyORB_HI_Generated.Transport</code>. This package contains the
routines to send and receive messages between the threads of the
application, either locally or remotely, depending on the source and
the destination of the message. In case of remote communication, the
transport high-level layer will invoke the routines of the transport
low level layer depending on the kind of the connection between the
source and the destination.

   <p>The example below shows the <code>PolyORB_HI_Generated.Transport</code>
generated for the node <code>Node_A</code> of the <code>Ping</code> example.

<pre class="smallexample">     
     --------------------------------------------------------
     -- <i> This file was automatically generated by Ocarina  --</i>
     -- <i> Do NOT hand-modify this file, as your             --</i>
     -- <i> changes will be lost when you re-run Ocarina      --</i>
     --------------------------------------------------------
     <b>pragma</b> Style_Checks
      ("<i>NM32766</i>");
     <b>with</b> PolyORB_HI_Generated.Deployment;
     <b>with</b> PolyORB_HI.Streams;
     <b>with</b> PolyORB_HI.Messages;
     <b>with</b> PolyORB_HI.Errors;
     
     <b>package</b> PolyORB_HI_Generated.Transport <b>is</b>
     
       <b>procedure</b> Deliver
        (Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Message : PolyORB_HI.Streams.Stream_Element_Array);
     
       <b>function</b> Send
        (From : PolyORB_HI_Generated.Deployment.Entity_Type;
         Entity : PolyORB_HI_Generated.Deployment.Entity_Type;
         Message : PolyORB_HI.Messages.Message_Type)
        <b>return</b> PolyORB_HI.Errors.Error_Kind;
     
     <b>end</b> PolyORB_HI_Generated.Transport;
     
</pre>
   <h5 class="subsubsection">B.2.2.8 Main subprogram</h5>

<p>The main subprogram is an Ada subprogram that does all the necessary
initialization before the effective run of the node. The defining
identifier of the main subprogram is mapped from the process
subcomponent &ldquo;instance&rdquo; declared in the system implementation. All
the naming rules listed in <a href="Whole-distributed-application.html#Whole-distributed-application">Whole distributed application</a> have to
be respected.

   <p>The body of the main subprogram contains the initialization of the
communication transport layer, then we no longer need the main task,
so we suspend it for ever. The following example shows the main
subprogram generated for the node <code>Node_A</code> of the <code>Ping</code>
example.

<pre class="smallexample">     
     --------------------------------------------------------
     -- <i> This file was automatically generated by Ocarina  --</i>
     -- <i> Do NOT hand-modify this file, as your             --</i>
     -- <i> changes will be lost when you re-run Ocarina      --</i>
     --------------------------------------------------------
     <b>pragma</b> Style_Checks
      ("<i>NM32766</i>");
     <b>with</b> PolyORB_HI_Generated.Activity;
     <b>pragma</b> Warnings (Off, PolyORB_HI_Generated.Activity);
     <b>pragma</b> Elaborate_All (PolyORB_HI_Generated.Activity);
     <b>with</b> System;
     <b>with</b> PolyORB_HI.Transport_Low_Level;
     <b>with</b> PolyORB_HI.Suspenders;
     
     ------------
     -- <i>Node_A -- </i>
     ------------
     
     <b>procedure</b> Node_A <b>is</b>
       <b>pragma</b> Priority
        (System.Priority'Last);
     <b>begin</b>
       -- <i> Initialize default communication subsystem</i>
       PolyORB_HI.Transport_Low_Level.Initialize;
       -- <i> Unblock all user tasks</i>
       PolyORB_HI.Suspenders.Unblock_All_Tasks;
       -- <i> Suspend forever instead of putting an endless loop. This saves the CPU </i>
       -- <i> resources.</i>
       PolyORB_HI.Suspenders.Suspend_Forever;
     <b>end</b> Node_A;
     
</pre>
   <p>In order to elaborate correctly the tasks, a special elaboration
clause has to be added for the <code>PolyORB_HI_Generated.Activity</code>
package in the main subprogram when the node contains periodic threads
(see the example above).

<!--  -->
</body></html>

