<html lang="en">
<head>
<title>Threads - PolyORB-HI-C User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="PolyORB-HI-C User's Guide">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="AADL-to-C-transformations.html#AADL-to-C-transformations" title="AADL to C transformations">
<link rel="prev" href="Hosts.html#Hosts" title="Hosts">
<link rel="next" href="Connections.html#Connections" title="Connections">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2007-2009, E'cole nationale supe'rieure des
te'lc'ommunications

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU Free Documentation License'', with the
Front-Cover Texts being ``PolyORB High Integrity C User's Guide'', and
with no Back-Cover Texts.  A copy of the license is included in the
section entitled ``GNU Free Documentation License''.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
body {}
body {
	background-color: white;
	position: absolute;
	font-size: medium;
	font-family: Verdana;
//	padding-left: 7em;
	top: 3em;
}

div.navigation {
	font-size: small; 
	padding-left: 0; 
	padding-right: 0; 
	text-align: right
}

div#menu {
	text-align: left;
	position: fixed;
	left: 1pt;
	bottom: auto;
	top: 2em;
	right: auto;
	padding-right: 1ex;
	padding-left: 1em;
	padding-top: 1ex;
	padding-bottom: 1ex;
	border-width: 3pt;
	background-color: transparent;  
	border-color: red; 
	border-left-style: solid
}

div#menu span.item {
	display: block;
	background-color: transparent;  
}

table.navigation {
	font-size: small
} 


/* Paragraphs */
p, blockquote {
	color: black; 
	text-indent: 1em; 
	text-align: justify
}


p {
	margin-bottom: .5em; 
	margin-top: 1px
}

p kbd 
{
  background-color: ivory
}

div.important {
	background-color: lightgray; 
	border-color: red; 
	border-style: solid;  
	border-width: 1pt
}
p.important {
	color: red
}
p.brut {
	text-indent: 0
}
p.brut:first-letter {
	font-size: 100%; 
	font-weight: normal
}

/* Sections */
div {
	border-style: none; 
	padding-left: 1em; 
	padding-right: 1em; 
	margin-top: 2px; 
	margin-bottom: 2px
}


/* Menus */

div.action {
	background-color: ivory; 
	border-color: lightgray; 
	border-style: solid; 
	border-width: 1pt 1pt 1pt 1pt; 
	font-size: small; 
	text-align: left
}

div.special 
{
  border-color: lightgray; 
  border-style: solid; 
  border-width: 0 0 0 4pt
}


/* Docbook special settings */

h3.subtitle {
	text-align: center
}

h1.title {
	margin-bottom: 10pt;
}

div.authorgroup {
	margin-top: 2em;
	margin-bottom: 2em;
	text-align: center;
	display: block;
}

div.author {
	display: inline;
}

h3.author {
	display: inline;
	font-style: normal;
	color: black;
	font-size: medium;
}

p.copyright {
	margin-top: 1em;
	text-align: center;
}

/* End docbook settings */


/* hors-texte */

pre {
	background-color: whitesmoke;
	border-color: lightcoral;
	border-style: solid;
	border-width: 0pt 1pt 1pt 0pt;
}

.hors-texte {
	background-color: lightgray;  
	border-color: lightcoral; 
	border-style: solid;
	border-width: 1pt; 
	padding-left: 1em; 	
	padding-right: 1em; 
	text-align: justify
}

/* Tables */

table.hors-texte {
	margin: auto; 
	font-size: 100%;
	border-width: 1pt 1pt 1pt 1pt
}

table.hors-texte td {
	padding-left: 1ex; 
	padding-right: 1ex
}

table.hors-texte tr.sep {
	padding-top: 1ex
}


h1, h2, h3, h4, h5, h6 
{
  color: black; 
  text-decoration: none; 
  font-weight: bold;
  padding: 0pt
}

h1 {
	font-size: larger larger larger;
	text-align: center; 
	margin-bottom: 24pt
}
h2 {
	font-size: larger larger;
	margin-left:      0; 
	margin-top:       24pt; 
	margin-bottom:    14pt;
	border-color:     red;
	border-bottom-style:     solid;
	border-width:     1pt;
	padding:          2pt; 
	margin-left:      0; 
	margin-right:     0; 
}
h3 {
	font-size: larger;
	margin-left: 1em; 
	margin-bottom: 1ex;
	color: red;	
}
h4, h5, h6 {
	font-size: normal;
	margin-left: 2em; 
	margin-bottom: 1em
}

h4 {
	text-decoration: underlined
}
h5 {
	font-style: italic
}


h2.special 
{
  border-style:     solid;
  border-width:	    1pt;
  border-color:     lightgray;
  padding:          2pt; 
}

img.flottant {
	float: right;
	clear: both;
	margin: 2em;
}

/* Lists */

li, dd 
{
  text-align: justify
}

dt {
	font-style: normal; 
	margin-top: 1em
}
dd {
	font-style: normal; 
	margin-left: 4em
}

dd.sdd {
	margin-left: 5em
}

dd ul {margin-top: 0}
li dl {margin-top: 0}
ul {list-style-type: square}
ul ul {list-style-type: disc}
ul ul ul {list-style-type: circle}

/* Addresses */

address {
	margin-top: 1ex; margin-bottom: 1ex
}
address.poste {
	font-style: italic
}
address.email {
	font-style: normal
}
address.phone {
	font-style: oblic
}

/* Links */

a:link, a:visited {
	color: darkred;
	text-decoration: none;
	border-bottom-width: 1px;
	border-bottom-style: dotted;
	border-bottom-color:  red;
	padding-bottom: 0px
}

a:hover, a:active {
	color: red; 
	text-decoration: none;
	border-bottom-color: black;
	border-bottom-style: solid
}

--></style>
</head>
<body>
<div class="node">
<p>
<a name="Threads"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Connections.html#Connections">Connections</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Hosts.html#Hosts">Hosts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="AADL-to-C-transformations.html#AADL-to-C-transformations">AADL to C transformations</a>
<hr>
</div>

<h3 class="section">B.4 Threads</h3>

<!--  -->
<p>The threads are the active part of the distributed application. A node
must contain at least one thread and may contain more than one
thread. In this section, we give the AADL entities used to model
threads. Then, we give the mapping rule to generate C code
corresponding to the periodic and aperiodic threads.

   <p>The rules are listed relatively to the packages generated for the
nodes and for the distributed application (see <a href="Distributed-application-nodes.html#Distributed-application-nodes">Distributed application nodes</a> and <a href="Whole-distributed-application.html#Whole-distributed-application">Whole distributed application</a>). Only
rules that are related directly to a thread as a whole subsystem are
listed here.

<h4 class="subsection">B.4.1 AADL entities</h4>

<p>The <code>thread</code> AADL components are used to model threads in the
distributed application. The <code>features</code> section of the thread
component declaration describe the thread interface (the ports that
may be connected to the ports of other threads). The <code>properties</code>
section of the thread implementation lists the properties of the
thread such as its priority, its nature (periodic,
sporadic) and many other properties ares expressed using AADL
properties. The <code>calls</code> section of the thread implementation
contains the sequences of subprograms the thread may call during its
job (see <a href="Subprograms.html#Subprograms">Subprograms</a> for more details on the subprogram
mapping). If the thread job consist of calling more than one
subprogram, it is <b>mandatory</b> to encapsulate these calls inside a
single subprogram which will consist the thread job. The
<code>connections</code> section of a thread implementation connects the
parameters of the subprograms called by the thread to the ports of the
threads or to the parameters of other called subprograms in the same
thread.

<pre class="smallexample">     
     <b>thread</b> P
     features
       Data_Source : <b>event</b> <b>out</b> <b>data</b> <b>port</b> Simple_Type;
     <b>end</b> P;
     
     <b>thread</b> <b>implementation</b> P.Impl
     <b>calls</b> {
       -- <i> ...</i>
     };
     <b>connections</b>
       -- <i> ...</i>
     <b>properties</b>
       Dispatch_Protocol =&gt; Periodic;
       Period            =&gt; 1000 Ms;
     <b>end</b> P.Impl;
     
     
</pre>
   <p>The listing above shows the thread <code>P</code> which belongs to the
process <code>A</code> in the <code>Ping</code> example. We can see that <code>P</code>
is a periodic thread with a period of $1000ms$, that this thread has a
unique <code>out event data port</code> and that at each period, the thread
performs a call to the <code>Do_Ping_Spg</code> subprogram whose <code>out
parameter</code> is connected to the thread port.

<h4 class="subsection">B.4.2 C mapping rules for periodic threads</h4>

<p>Periodic threads are cyclic threads that are triggered by and only by
a periodic time event. between two time events the periodic threads do
a non blocking job and then they sleep waiting for the next time
event.

<h5 class="subsubsection">B.4.2.1 Node activity</h5>

<p>The majority of the code generated for the periodic threads is put
in the <samp><span class="file">activity.c</span></samp> file generated for the application
node containing the handled thread. Each periodic thread is created in the
main function (<samp><span class="file">main.c</span></samp> file) with the <code>__po_hi_create_periodic_task</code>
function-call.

   <p>The generated code in the <samp><span class="file">activity.c</span></samp> file is a parameterless function
that represents the thread job. The defining identifier of the function
is mapped from the thread instance name in the process that models the node,
to which we append the string &ldquo;<code>_job</code>&rdquo;. All the naming rules listed
in <a href="Whole-distributed-application.html#Whole-distributed-application">Whole distributed application</a> have to be respected. The body of this
subprogram calls the subprograms mapped from the subprogram calls the
thread performs. Then, it sends the request to the remote threads it
may be connected to. Finally, at the end of the function, we make a call
to the <code>__po_hi_wait_next_period()</code> with the task identifier as parameter. 
This call ensure that we wait the next period before we start the function
again.

   <p>The generated code in <samp><span class="file">main.c</span></samp> file is a function-call that creates
a periodic task. The task is created with the function
<code>__po_hi_create_periodic_task</code>. This creates a periodic task with
the wanted properties at the elaboration time of the node. The package
instantiation name is mapped from the thread instance name in the process
that model the node, to which we append the string &ldquo;<code>_k</code>&rdquo;. All the
naming rules listed in <a href="Whole-distributed-application.html#Whole-distributed-application">Whole distributed application</a> have to be
respected. The function-call takes the following parameters:
     <ul>
    <li>the enumerator corresponding to the thread
    <li>the task period,
    <li>the task priority. If the user did not specify a priority, then
    <code>__PO_HI_DEFAULT_PRIORITY</code> is used,
    <li>the task job which corresponds to the subprogram
    <code>&lt;Thread_Name&gt;_job</code>. 
  </ul>

   <p>The following example shows the generated code for the periodic thread
<code>Pinger</code> from the node <code>Node_A</code> of the <code>Ping</code> example:

<pre class="smallexample">     
     #include &lt;po_hi_types.h&gt;
     #include &lt;po_hi_gqueue.h&gt;
     #include &lt;request.h&gt;
     #include &lt;deployment.h&gt;
     #include &lt;types.h&gt;
     #include &lt;subprograms.h&gt;
     #include &lt;po_hi_task.h&gt;
     #include &lt;po_hi_main.h&gt;
     #include &lt;marshallers.h&gt;
     extern __po_hi_entity_t __po_hi_port_global_to_entity[__PO_HI_NB_PORTS];
     extern __po_hi_port_t __po_hi_port_global_to_local[__PO_HI_NB_PORTS];
     __po_hi_int8_t __po_hi_data_source_local_destinations[1] = {ping_me_global_data_sink};
     __po_hi_uint8_t __po_hi_pinger_woffsets[__po_hi_pinger_nb_ports];
     __po_hi_uint8_t __po_hi_pinger_offsets[__po_hi_pinger_nb_ports];
     __po_hi_uint8_t __po_hi_pinger_used_size[__po_hi_pinger_nb_ports];
     __po_hi_uint8_t __po_hi_pinger_empties[__po_hi_pinger_nb_ports];
     __po_hi_uint8_t __po_hi_pinger_first[__po_hi_pinger_nb_ports];
     __po_hi_uint8_t __po_hi_pinger_recent[__po_hi_pinger_nb_ports * sizeof(__po_hi_request_t)];
     __po_hi_uint8_t __po_hi_pinger_queue[0 * sizeof(__po_hi_request_t)];
     __po_hi_uint16_t __po_hi_pinger_total_fifo_size = 0;
     __po_hi_port_t __po_hi_pinger_history[0];
     __po_hi_uint8_t __po_hi_pinger_n_dest[__po_hi_pinger_nb_ports] = {1};
     __po_hi_int8_t __po_hi_pinger_fifo_size[__po_hi_pinger_nb_ports] = {__PO_HI_GQUEUE_FIFO_OUT};
     __po_hi_uint8_t* __po_hi_pinger_destinations[__po_hi_pinger_nb_ports] = {__po_hi_data_source_local_destinations};
     /*  Periodic task : Pinger*/
     
     /****************/
     /* pinger_job   */
     /****************/
     
     void* pinger_job ()
     {
        simple_type data_source_request_var;
        __po_hi_request_t data_source_request;
     
        __po_hi_gqueue_init(node_a_pinger_k,__po_hi_pinger_nb_ports,__po_hi_pinger_queue,__po_hi_pinger_fifo_size,__po_hi_pinger_first,__po_hi_pinger_offsets,__po_hi_pinger_woffsets,__po_hi_pinger_n_dest,__po_hi_pinger_destinations,__po_hi_pinger_used_size,__po_hi_pinger_history,__po_hi_pinger_recent,__po_hi_pinger_empties,__po_hi_pinger_total_fifo_size);
        __po_hi_wait_initialization();
        while (1)
        {
           /*  Call implementation*/
           do_ping_spg(&amp;(data_source_request_var));
           /*  Set the OUT port values*/
           data_source_request.vars.pinger_global_data_source.pinger_global_data_source = data_source_request_var;
           data_source_request.port = data_source_request_var;
           __po_hi_gqueue_store_out(node_a_pinger_k,pinger_local_data_source,&amp;(data_source_request));
           /*  Send the OUT ports*/
           __po_hi_gqueue_send_output(node_a_pinger_k,pinger_global_data_source);
           __po_hi_wait_for_next_period(node_a_pinger_k);
        }
     }
     
     
     /**************************/
     /* __po_hi_main_deliver   */
     /**************************/
     
     <b>void</b> __po_hi_main_deliver
           (__po_hi_msg_t* message)
     {
        __po_hi_request_t request;
        __po_hi_entity_t entity;
     
        __po_hi_unmarshall_request(&amp;(request),message);
        entity = __po_hi_port_global_to_entity[request.port];
        <b>switch</b> (entity)
        {
           default:
           {
              break;
           }
        }
     }
     
     
     
</pre>
   <h4 class="subsection">B.4.3 C mapping rules for sporadic threads</h4>

<p>Sporadic threads are <em>cyclic</em> threads that are triggered by an
sporadic event. The minimum inter-arrival time between two sporadic
event is called the period of the sporadic thread.

<h5 class="subsubsection">B.4.3.1 Node activity</h5>

<p>The majority of the code generated for the sporadic threads is put
in the <samp><span class="file">activity.c</span></samp> file generated for the application
node containing the handled thread. Each periodic thread is created in the
main function (<samp><span class="file">main.c</span></samp> file) with the <code>__po_hi_create_sporadic_task</code>
function-call.

   <p>The generated code in the <samp><span class="file">activity.c</span></samp> file is a parameterless function
that represents the thread job. The defining identifier of the function
is mapped from the thread instance name in the process that models the node,
to which we append the string &ldquo;<code>_job</code>&rdquo;. All the naming rules listed
in <a href="Whole-distributed-application.html#Whole-distributed-application">Whole distributed application</a> have to be respected. In the body
of the function, the thread will wait for an event (most of the time : a
message from another entity).

   <p>The generated code in <samp><span class="file">main.c</span></samp> file is a function-call that creates
the sporadic task. The task is created with the function
<code>__po_hi_create_sporadic_task</code>. This creates a sporadic task with
the wanted properties at the elaboration time of the node. The package
instantiation name is mapped from the thread instance name in the process
that model the node, to which we append the string &ldquo;<code>_k</code>&rdquo;. All the
naming rules listed in <a href="Whole-distributed-application.html#Whole-distributed-application">Whole distributed application</a> have to be
respected. The function-call takes the following parameters:
     <ul>
    <li>the enumerator corresponding to the thread
    <li>the task priority. If the user did not specify a priority, then
    <code>__PO_HI_DEFAULT_PRIORITY</code> is used,
    <li>the task job which corresponds to the subprogram
    <code>&lt;Thread_Name&gt;_job</code>. 
  </ul>

   <p>The following example shows the generated code for the sporadic thread
<code>Ping_Me</code> from the node <code>Node_B</code> of the <code>Ping</code> example.

<pre class="smallexample">     
     #include &lt;po_hi_gqueue.h&gt;
     #include &lt;po_hi_types.h&gt;
     #include &lt;request.h&gt;
     #include &lt;deployment.h&gt;
     #include &lt;po_hi_task.h&gt;
     #include &lt;subprograms.h&gt;
     #include &lt;po_hi_main.h&gt;
     #include &lt;marshallers.h&gt;
     extern __po_hi_entity_t __po_hi_port_global_to_entity[__PO_HI_NB_PORTS];
     extern __po_hi_port_t __po_hi_port_global_to_local[__PO_HI_NB_PORTS];
     __po_hi_uint8_t __po_hi_ping_me_woffsets[__po_hi_ping_me_nb_ports];
     __po_hi_uint8_t __po_hi_ping_me_offsets[__po_hi_ping_me_nb_ports];
     __po_hi_uint8_t __po_hi_ping_me_used_size[__po_hi_ping_me_nb_ports];
     __po_hi_uint8_t __po_hi_ping_me_empties[__po_hi_ping_me_nb_ports];
     __po_hi_uint8_t __po_hi_ping_me_first[__po_hi_ping_me_nb_ports];
     __po_hi_uint8_t __po_hi_ping_me_recent[__po_hi_ping_me_nb_ports * sizeof(__po_hi_request_t)];
     __po_hi_uint8_t __po_hi_ping_me_queue[16 * sizeof(__po_hi_request_t)];
     __po_hi_uint16_t __po_hi_ping_me_total_fifo_size = 16;
     __po_hi_port_t __po_hi_ping_me_history[16];
     __po_hi_uint8_t __po_hi_ping_me_n_dest[__po_hi_ping_me_nb_ports] = {0};
     __po_hi_int8_t __po_hi_ping_me_fifo_size[__po_hi_ping_me_nb_ports] = {16};
     __po_hi_uint8_t* __po_hi_ping_me_destinations[__po_hi_ping_me_nb_ports] = {NULL};
     
     /*********************/
     /* ping_me_deliver   */
     /*********************/
     
     <b>void</b> ping_me_deliver
           (__po_hi_request_t* request)
     {
     
        <b>switch</b> (request-&gt;port)
        {
           <b>case</b> ping_me_global_data_sink:
           {
              __po_hi_gqueue_store_in(node_b_ping_me_k,ping_me_local_data_sink,request);
     
              break;
           }
           default:
           {
              break;
           }
        }
     }
     
     /*  Sporadic task : Ping_Me*/
     /*  Get the IN ports values*/
     
     /*****************/
     /* ping_me_job   */
     /*****************/
     
     void* ping_me_job ()
     {
        __po_hi_port_t port;
        __po_hi_request_t data_sink_request;
     
        __po_hi_gqueue_init(node_b_ping_me_k,__po_hi_ping_me_nb_ports,__po_hi_ping_me_queue,__po_hi_ping_me_fifo_size,__po_hi_ping_me_first,__po_hi_ping_me_offsets,__po_hi_ping_me_woffsets,__po_hi_ping_me_n_dest,__po_hi_ping_me_destinations,__po_hi_ping_me_used_size,__po_hi_ping_me_history,__po_hi_ping_me_recent,__po_hi_ping_me_empties,__po_hi_ping_me_total_fifo_size);
        __po_hi_wait_initialization();
        while (1)
        {
           __po_hi_gqueue_wait_for_incoming_event(node_b_ping_me_k,&amp;(port));
           __po_hi_compute_next_period(node_b_ping_me_k);
           <b>if</b> (__po_hi_gqueue_get_count(node_b_ping_me_k,ping_me_local_data_sink))
           {
                    __po_hi_gqueue_get_value(node_b_ping_me_k,ping_me_local_data_sink,&amp;(data_sink_request));
              __po_hi_gqueue_next_value(node_b_ping_me_k,ping_me_local_data_sink);
     
           }
           /*  Call implementation*/
           ping_spg(data_sink_request.vars.ping_me_global_data_sink.ping_me_global_data_sink);
           __po_hi_wait_for_next_period(node_b_ping_me_k);
        }
     }
     
     
     /**************************/
     /* __po_hi_main_deliver   */
     /**************************/
     
     <b>void</b> __po_hi_main_deliver
           (__po_hi_msg_t* message)
     {
        __po_hi_request_t request;
        __po_hi_entity_t entity;
     
        __po_hi_unmarshall_request(&amp;(request),message);
        entity = __po_hi_port_global_to_entity[request.port];
        <b>switch</b> (entity)
        {
           <b>case</b> node_b_ping_me_k_entity:
           {
              ping_me_deliver(&amp;(request));
     
              break;
           }
           default:
           {
              break;
           }
        }
     }
     
     
     
</pre>
   <h4 class="subsection">B.4.4 Deployment information</h4>

<p>As said in <a href="Distributed-application-nodes.html#Distributed-application-nodes">Distributed application nodes</a>, the files <samp><span class="file">deployment.h</span></samp>
and <samp><span class="file">deployment.c</span></samp> are generated for each node in the distributed
application. For each thread port in the whole distributed application, we declare an
enumerator in this type. The defining identifier of the enumerator is
mapped from the process subcomponent name and the thread subcomponent
name as follows: <code>&lt;Node_Name&gt;_&lt;Thread_Name&gt;_K</code>. 
For each that that may communicate, we generate the following elements
     <ul>
   <li>A variable called <code>__po_hi_&lt;thread_name&gt;_local_to_global</code>
   (in <code>deployment.c</code>) that is used to convert a local port
   identifier of the thread to a global one.

     <li>A type <code>__po_hi_&lt;thread_name&gt;_t</code> that will contain
   on local port identifier.

     <li>A macro <code>__po_hi_&lt;thread_name&gt;_nb_ports</code> that will contain
   the number of ports for the thread. 
</ul>

   <p>For these elements, all the naming
rules listed in <a href="Whole-distributed-application.html#Whole-distributed-application">Whole distributed application</a> must be respected.

<pre class="smallexample">     
     #ifndef __DEPLOYMENT_H_
     #define __DEPLOYMENT_H_
     #include &lt;po_hi_protected.h&gt;
     <b>typedef</b> <b>enum</b>
     {
        pinger_local_data_source = 0
     } __po_hi_pinger_t;
     
     #define __po_hi_pinger_nb_ports 1
     
     <b>typedef</b> <b>enum</b>
     {
        ping_me_local_data_sink = 0
     } __po_hi_ping_me_t;
     
     #define __po_hi_ping_me_nb_ports 1
     
     /*  For each node in the distributed application add an <b>enum</b>erator*/
     
     <b>typedef</b> <b>enum</b>
     {
        node_a_k = 0,
        node_b_k = 1
     } __po_hi_node_t;
     
     /*  For each thread in the distributed application nodes, add an <b>enum</b>erator*/
     
     <b>typedef</b> <b>enum</b>
     {
        node_a_pinger_k_entity = 0,
        node_b_ping_me_k_entity = 1
     } __po_hi_entity_t;
     
     <b>typedef</b> <b>enum</b>
     {
        node_a_pinger_k = 0
     } __po_hi_task_id;
     
     #define __PO_HI_NB_TASKS 1
     
     /*  For each thread in the distributed application nodes THAT MAY COMMUNICATE*/
     /*   with the current node, add an <b>enum</b>erator*/
     
     <b>typedef</b> <b>enum</b>
     {
        invalid_server = -1
     } __po_hi_entity_server_t;
     
     #define __PO_HI_NB_SERVERS 0
     
     #define __PO_HI_NB_PROTECTED 0
     
     #define __PO_HI_NB_NODES 2
     
     #define __PO_HI_NB_ENTITIES 2
     
     #define __PO_HI_NB_PORTS 2
     
     <b>typedef</b> <b>enum</b>
     {
        pinger_global_data_source = 0,
        ping_me_global_data_sink = 1
     } __po_hi_port_t;
     
     #endif
     
</pre>
   <pre class="smallexample">     
     #include &lt;deployment.h&gt;
     __po_hi_entity_server_t server_entity_table[__PO_HI_NB_ENTITIES] = {invalid_server,invalid_server};
     __po_hi_node_t entity_table[__PO_HI_NB_ENTITIES] = {node_a_k,node_b_k};
     __po_hi_node_t mynode = node_a_k;
     
     
</pre>
   <p>The listing above shows the generated <code>__po_hi_entity_server_t</code> and
<code>entity_table</code> for the nodes <code>B</code> from the
<code>Ping</code> example.

<h4 class="subsection">B.4.5 Port mapping</h4>

<p>Threads can contain one or several ports. To handle them, we declared several
arrays in the <code>activity.c</code>
     <ul>
   <li><code>__po_hi_&lt;port_name&gt;_destinations</code> : array for each port of the
   thread which contains all destinations of the port. 
   <li><code>__po_hi_&lt;thread_name&gt;_woffsets</code> : array (size = number of ports in the
   thread) used by \pohic for the global queue of the thread. 
   <li><code>__po_hi_&lt;thread_name&gt;_offsets</code> : array (size = number of ports in the
      thread) used by \pohic for the global queue of the thread. 
   <li><code>__po_hi_&lt;thread_name&gt;_used_size</code> : array (size = number of ports in the
      thread) used by \pohic for the global queue of the thread. 
   <li><code>__po_hi_&lt;thread_name&gt;_empties</code> : array (size = number of ports in the
      thread) used by \pohic for the global queue of the thread. 
   <li><code>__po_hi_&lt;thread_name&gt;_first</code> : array (size = number of ports in the
      thread) used by \pohic for the global queue of the thread. 
   <li><code>__po_hi_&lt;thread_name&gt;_recent</code> : array (size = number of ports in the
      thread) used by \pohic for the global queue of the thread. 
   <li><code>__po_hi_&lt;thread_name&gt;_queue</code> : array (size = size of the global queue
   for the thread) used by \pohic to handle the global queue. 
   <li><code>__po_hi_&lt;thread_name&gt;_total_fifo_size</code> : variable that contains
   the size of the global queue. It is the sum of all port size for the thread. 
   <li><code>__po_hi_&lt;thread_name&gt;_history</code> : array (size = number of ports in the
      thread) used by \pohic for the global queue of the thread. 
   <li><code>__po_hi_&lt;thread_name&gt;_n_dest</code> : array (size = number of ports in the
      thread) used by \pohic for the global queue of the thread. It contains
      the number of destinations for each port of the thread. 
   <li><code>__po_hi_&lt;thread_name&gt;_fifo_size</code> : array (size = number of ports in the
      thread) used by \pohic for the global queue of the thread. 
   <li><code>__po_hi_&lt;thread_name&gt;_destinations</code> : array (size = number of ports
   in the thread) that contains all destinations for each port. 
</ul>

<!--  -->
</body></html>

