<html lang="en">
<head>
<title>API to build and manipulate AADL models - Ocarina: A Compiler for the AADL</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="description" content="Ocarina: A Compiler for the AADL">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="The-Ocarina-Core-Library.html#The-Ocarina-Core-Library" title="The Ocarina Core Library">
<link rel="prev" href="Low-level-API-to-manipulate-tree-nodes.html#Low-level-API-to-manipulate-tree-nodes" title="Low level API to manipulate tree nodes">
<link rel="next" href="API-to-build-and-manipulate-AADL-instances.html#API-to-build-and-manipulate-AADL-instances" title="API to build and manipulate AADL instances">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2003-2007 E'cole
nationale supe'rieure des te'le'communications

Permission is granted to make and distribute verbatim copies of this
entire document without royalty provided the copyright notice and
this permission are preserved.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
body {}
body {
	background-color: white;
	position: absolute;
	font-size: medium;
	font-family: Verdana;
//	padding-left: 7em;
	top: 3em;
}

div.navigation {
	font-size: small; 
	padding-left: 0; 
	padding-right: 0; 
	text-align: right
}

div#menu {
	text-align: left;
	position: fixed;
	left: 1pt;
	bottom: auto;
	top: 2em;
	right: auto;
	padding-right: 1ex;
	padding-left: 1em;
	padding-top: 1ex;
	padding-bottom: 1ex;
	border-width: 3pt;
	background-color: transparent;  
	border-color: red; 
	border-left-style: solid
}

div#menu span.item {
	display: block;
	background-color: transparent;  
}

table.navigation {
	font-size: small
} 


/* Paragraphs */
p, blockquote {
	color: black; 
	text-indent: 1em; 
	text-align: justify
}


p {
	margin-bottom: .5em; 
	margin-top: 1px
}

p kbd 
{
  background-color: ivory
}

div.important {
	background-color: lightgray; 
	border-color: red; 
	border-style: solid;  
	border-width: 1pt
}
p.important {
	color: red
}
p.brut {
	text-indent: 0
}
p.brut:first-letter {
	font-size: 100%; 
	font-weight: normal
}

/* Sections */
div {
	border-style: none; 
	padding-left: 1em; 
	padding-right: 1em; 
	margin-top: 2px; 
	margin-bottom: 2px
}


/* Menus */

div.action {
	background-color: ivory; 
	border-color: lightgray; 
	border-style: solid; 
	border-width: 1pt 1pt 1pt 1pt; 
	font-size: small; 
	text-align: left
}

div.special 
{
  border-color: lightgray; 
  border-style: solid; 
  border-width: 0 0 0 4pt
}


/* Docbook special settings */

h3.subtitle {
	text-align: center
}

h1.title {
	margin-bottom: 10pt;
}

div.authorgroup {
	margin-top: 2em;
	margin-bottom: 2em;
	text-align: center;
	display: block;
}

div.author {
	display: inline;
}

h3.author {
	display: inline;
	font-style: normal;
	color: black;
	font-size: medium;
}

p.copyright {
	margin-top: 1em;
	text-align: center;
}

/* End docbook settings */


/* hors-texte */

pre {
	background-color: whitesmoke;
	border-color: lightcoral;
	border-style: solid;
	border-width: 0pt 1pt 1pt 0pt;
}

.hors-texte {
	background-color: lightgray;  
	border-color: lightcoral; 
	border-style: solid;
	border-width: 1pt; 
	padding-left: 1em; 	
	padding-right: 1em; 
	text-align: justify
}

/* Tables */

table.hors-texte {
	margin: auto; 
	font-size: 100%;
	border-width: 1pt 1pt 1pt 1pt
}

table.hors-texte td {
	padding-left: 1ex; 
	padding-right: 1ex
}

table.hors-texte tr.sep {
	padding-top: 1ex
}


h1, h2, h3, h4, h5, h6 
{
  color: black; 
  text-decoration: none; 
  font-weight: bold;
  padding: 0pt
}

h1 {
	font-size: larger larger larger;
	text-align: center; 
	margin-bottom: 24pt
}
h2 {
	font-size: larger larger;
	margin-left:      0; 
	margin-top:       24pt; 
	margin-bottom:    14pt;
	border-color:     red;
	border-bottom-style:     solid;
	border-width:     1pt;
	padding:          2pt; 
	margin-left:      0; 
	margin-right:     0; 
}
h3 {
	font-size: larger;
	margin-left: 1em; 
	margin-bottom: 1ex;
	color: red;	
}
h4, h5, h6 {
	font-size: normal;
	margin-left: 2em; 
	margin-bottom: 1em
}

h4 {
	text-decoration: underlined
}
h5 {
	font-style: italic
}


h2.special 
{
  border-style:     solid;
  border-width:	    1pt;
  border-color:     lightgray;
  padding:          2pt; 
}

img.flottant {
	float: right;
	clear: both;
	margin: 2em;
}

/* Lists */

li, dd 
{
  text-align: justify
}

dt {
	font-style: normal; 
	margin-top: 1em
}
dd {
	font-style: normal; 
	margin-left: 4em
}

dd.sdd {
	margin-left: 5em
}

dd ul {margin-top: 0}
li dl {margin-top: 0}
ul {list-style-type: square}
ul ul {list-style-type: disc}
ul ul ul {list-style-type: circle}

/* Addresses */

address {
	margin-top: 1ex; margin-bottom: 1ex
}
address.poste {
	font-style: italic
}
address.email {
	font-style: normal
}
address.phone {
	font-style: oblic
}

/* Links */

a:link, a:visited {
	color: darkred;
	text-decoration: none;
	border-bottom-width: 1px;
	border-bottom-style: dotted;
	border-bottom-color:  red;
	padding-bottom: 0px
}

a:hover, a:active {
	color: red; 
	text-decoration: none;
	border-bottom-color: black;
	border-bottom-style: solid
}

--></style>
</head>
<body>
<div class="node">
<p>
<a name="API-to-build-and-manipulate-AADL-models"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="API-to-build-and-manipulate-AADL-instances.html#API-to-build-and-manipulate-AADL-instances">API to build and manipulate AADL instances</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Low-level-API-to-manipulate-tree-nodes.html#Low-level-API-to-manipulate-tree-nodes">Low level API to manipulate tree nodes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="The-Ocarina-Core-Library.html#The-Ocarina-Core-Library">The Ocarina Core Library</a>
<hr>
</div>

<h4 class="subsection">6.1.4 API to build and manipulate AADL models</h4>

<p>This section describes the high level function's to manipulate AADL models:

     <ol type=1 start=1>

     <li>Builder API~: These functions (declared in the <code>Ocarina.Builder</code>
hierarchy) are provided to create the main kinds of nodes: components,
namespaces, subclauses, annexes, properties, etc. They are named
<code>Add_New_....</code>. They create a new node and insert it as a child of a
parent node, except for the root node. This helps ensure that the
description structure is valid, since the API only allows valid
constructions. All these functions take at least three parameters:

          <ul>
<li>the location of the node; for example the position in a file that
corresponds to the element that is parsed; the location is of type
Location as defined in the package <code>Locations</code>;

          <li>the name that should be set for the node, since all those nodes can
have names; the name is an identifier node; for some entities it can be
set to <code>No_Node</code> (connections, etc.);

          <li>the namespace or the parent node, which shall contain the newly
created node; this node must be different from <code>No_Node</code>, and has to
be of a correct kind, according to the AADL standard BNF.

     </ul>

     <p>Other parameters may be required, to specify information such as the
category of the component (bus, process, etc.), whether the subclause
is a refinement, etc. Some parameters have default values, meaning
that they can be omitted if the value is not known when the node is
created; the values can be set later, using lower-level access
functions.  Functions simply named <code>Add_...</code> are used internally to
add child nodes to their parents. No verification is performed; they
just ensure the child lists are created before inserting the node in
them.

     <li>Verification API: Functions are provided to check the validity of
AADL models. They ensure that all referenced AADL entities are
declared, that their type is correct, etc. They also check that AADL
properties are consistent.

     <li>Interrogation API: These functions (declared in the
<code>Ocarina.Analyzer</code> hierarchy) are provided to interrogate AADL
models in order to find entities, get properties, etc.

        </ol>

<h5 class="subsubsection">6.1.4.1 Ocarina.Builder</h5>

<p>This package defines no subprogram

<h5 class="subsubsection">6.1.4.2 Ocarina.Builder.AADL</h5>

<p>This package defines no subprogram

<h5 class="subsubsection">6.1.4.3 Ocarina.Builder.AADL.Annexes</h5>

<p>This package provides functions to build annex nodes into the AADL
tree.

   <p>This package defines the following subprograms:

   <p><strong>Set_Annex_Content</strong>: Set the text of the annex. Annex is the Node_Id of the annex
library or subclause, returned by Add_New_Annex_Subclause or
Add_New_Annex_Library. Text is the Name_Id referencing the text
of the annex. Return True is everything went right, else False.

<pre class="example">     <b>function </b>Set_Annex_Content
          (Annex : Types.Node_Id;
           Text  : Types.Name_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_New_Annex_Subclause</strong>: Create a new annex subclause. An annex subclause can be
inserted into a component declaration (type or implementation)
or a port group declaration. Loc is the location of the annex
in the parsed text. Annex_Name is the name of the annex
subclause. Namespace is the component or the port group where
the annex must be inserted. This functions returns the Node_Id
of the newly created annex subclause node, or No_Node if
something went wrong.

<pre class="example">     <b>function </b>Add_New_Annex_Subcla<b>use </b>     (Loc        : Locations.Location;
           Annex_Name : Types.Node_Id;
           Namespace  : Types.Node_Id;
           In_Modes   : Types.Node_Id)
          <b>return </b>Types.Node_Id;
</pre>
   <p><strong>Add_New_Annex_Library</strong>: Create a new annex library. An annex library can be inserted
into a package or the top level AADL specification (i.e. the
unnamed namespace). Loc is the location of the annex in the
parsed text. Annex_Name is the name of the annex
library. Namespace is the package specification or the top
level AADL specification where the annex must be inserted. This
functions returns the Node_Id of the newly created annex
library node, or No_Node if something went wrong.

<pre class="example">     <b>function </b>Add_New_Annex_Library
          (Loc        : Locations.Location;
           Annex_Name : Types.Node_Id;
           Namespace  : Types.Node_Id;
           Is_Private : Boolean             := False)
          <b>return </b>Types.Node_Id;
</pre>
   <p><strong>Add_New_Annex_Path</strong>: Create a new annex path node. Loc is the location of the annex
path in the parsed text. Container is the namespace which contain
the annex path declaration. Annex_Identifier is the identifier of
the annex path, it maybe No_Node. List_Identifiers is the list of
identifiers declared. This function returns the Node_Id of the
newly created annex path node, or No_Node if something went wrong.

<pre class="example">     <b>function </b>Add_New_Annex_Path
          (Loc              : Locations.Location;
           Container        : Types.Node_Id;
           Annex_Identifier : Types.Node_Id;
           List_Identifiers : Types.List_Id)
          <b>return </b>Types.Node_Id;
</pre>
   <h5 class="subsubsection">6.1.4.4 Ocarina.Builder.AADL.Components</h5>

<p>This package defines the following subprograms:

   <p><strong>Add_Annex</strong>: Add an annex subclause into a component (type or
implementation). Component is a Node_Id referencing the
component. Annex is a Node_Id referencing the annex
subclause. Returns True if the annex was correctly added into
the component, else False.

<pre class="example">     <b>function </b>Add_Annex
          (Component : Node_Id;
           Annex     : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_Connection</strong>: Add a connection into a component implementation. Component is
a Node_Id referencing the component implementation. Connection
is a Node_Id referencing the connection. Returns True if the
connection was correctly added into the component, else False.

<pre class="example">     <b>function </b>Add_Connection
          (Component  : Node_Id;
           Connection : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_Feature</strong>: Add a feature into a component type. Component is a Node_Id
referencing the component type. Feature is a Node_Id
referencing the feature. Returns True if the feature was
correctly added into the component, else False.

<pre class="example">     <b>function </b>Add_Feature
          (Component : Node_Id;
           Feature   : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_Refined_Type</strong>: Add a refined type into a component implementation. Refined
types correspond to refinements of the component type features.

<pre class="example">     <b>function </b>Add_Refined_Type
          (Component : Node_Id;
           Refined_Type : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_Subcomponent</strong>: Add a subcomponent into a component implementation. Component
is a Node_Id referencing the component
implementation. Subcomponent is a Node_Id referencing the
subcomponent. Returns True if the subcomponent was correctly
added into the component, else False.

<pre class="example">     <b>function </b>Add_Subcomponent
          (Component    : Node_Id;
           Subcomponent : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_Prototype</strong>: Add a prototype into a component implementation or a component type. 
Component is a Node_Id referencing the component implementation or the
component type. Prototype is a Node_Id referencing the prototype. 
Returns True if the prototype was correctly added into the component,
else False.

<pre class="example">     <b>function </b>Add_Proto<b>type </b>     (Component : Node_Id;
           Proto<b>type </b>: Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_Subprogram_Call_Sequence</strong>: Add a subprogram call sequence into a component
implementation. Component is a Node_Id referencing the
component implementation. Call_Sequence is a Node_Id
referencing the subcomponent. Returns True if the sequence was
correctly added into the component, else False.

<pre class="example">     <b>function </b>Add_Subprogram_Call_Sequence
          (Component     : Node_Id;
           Call_Sequence : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_Flow_Spec</strong>: Add a flow specification into a component type. Component is a
Node_Id referencing the component type. Flow_Spec is a Node_Id
referencing the flow. Returns True if the flow was correctly
added into the component, else False.

<pre class="example">     <b>function </b>Add_Flow_Spec
          (Component : Node_Id;
           Flow_Spec : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_Flow_Implementation</strong>: Add a flow implementation into a component
implementation. Component is a Node_Id referencing the
component implementation. Flow_Impl is a Node_Id referencing
the flow. Returns True if the flow was correctly added into the
component, else False.

<pre class="example">     <b>function </b>Add_Flow_Implementation
          (Component : Node_Id;
           Flow_Impl : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_End_To_End_Flow_Spec</strong>: Add an end to end flow specification into a component
implementation. Component is a Node_Id referencing the
component implementation. Flow_Impl is a Node_Id referencing
the flow. Returns True if the flow was correctly added into the
component, else False.

<pre class="example">     <b>function </b>Add_End_To_End_Flow_Spec
          (Component       : Node_Id;
           End_To_End_Flow : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_Mode</strong>: Add a mode (declaration or transition) into a component
implementation. Component is a Node_Id referencing the
component implementation. Mode is a Node_Id referencing the
mode declaration or mode transition. Returns True if the mode
was correctly added into the component, else False.

<pre class="example">     <b>function </b>Add_Mode
          (Component : Node_Id;
           Mode      : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_Property_Association</strong>: Add a property association into a component (type or
implementation). Component is a Node_Id referencing the
component type or implementation. Property_Association is a
Node_Id referencing the property association. Returns True if
the property was correctly added into the component, else
False. 
Component creation

<pre class="example">     <b>function </b>Add_Property_Association
          (Component            : Node_Id;
           Property_Association : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_New_Component_Type</strong>: Create a new component type node. A component type can be
inserted into a package or the top level AADL specification
(aka the unnamed namespace). Loc is the location of the
component in the parsed text. Identifier is a Node_Id
referencing the name of the component. Namespace is either a
package specification or the top level AADL
specification. Component_Type is the component category
(processor, memory, process, etc.). Is_Private indicates if the
component is declaraed in the private or the public part of the
package; it is only relevant if Namespace references a package
specification. Returns the Node_Id of the newly created
component type node, or No_Node if something went wrong.

<pre class="example">     <b>function </b>Add_New_Component_Type
          (Loc            : Location;
           Identifier     : Node_Id;
           Namespace      : Node_Id;
           Component_Type : Ocarina.ME_AADL.Component_Category;
           Is_Private     : Boolean := False)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Component_Implementation</strong>: Create a new component implementation node. A component
implementation can be inserted into a package or the top level
AADL specification (aka the unnamed namespace). Loc is the
location of the component in the parsed text. Identifier is a
Node_Id referencing the name of the component. Namespace is
either a package specification or the top level AADL
specification. Component_Type is the component category
(processor, memory, process, etc.). Is_Private indicates if the
component is declaraed in the private or the public part of the
package; it is only relevant if Namespace references a package
specification. Returns the Node_Id of the newly created
component implementation node, or No_Node if something went
wrong.

<pre class="example">     <b>function </b>Add_New_Component_Implementation
          (Loc            : Location;
           Identifier     : Node_Id;
           Namespace      : Node_Id;
           Component_Type : Ocarina.ME_AADL.Component_Category;
           Is_Private     : Boolean := False)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Feature_Group</strong>: Create a new feature group type (AADL_V2) or port group type (AADL_V1). 
It can be inserted into a package or the top level AADL specification.)

<pre class="example">     <b>function </b>Add_New_Feature_Group
          (Loc        : Location;
           Name       : Node_Id;
           Namespace  : Node_Id;
           Is_Private : Boolean := False)
          <b>return </b>Node_Id;
</pre>
   <h5 class="subsubsection">6.1.4.5 Ocarina.Builder.AADL.Components.Connections</h5>

<p>This package defines the following subprograms:

   <p><strong>Add_Property_Association</strong>: Add a property association to the connection
declaration. Connection must reference a connection
declaration. Property_Association references the property
association. Return True if everything went right, else False.

<pre class="example">     <b>function </b>Add_Property_Association
          (Connection           : Node_Id;
           Property_Association : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_New_Connection</strong>: Create and add a new connection into a component
implementation. Loc is the location of the connection in the
parsed text. Name references an identifier which contains the
name of the connection, if any. Comp_Impl references the
component implementation. Category is the type of the
connection. Is_Refinement indicates wether the connection is a
refinement or not. Source and Destination are the left and
right memebers of the connection. In_Modes contains the list of
the modes associated to the connection. Name can be No_Node, if
the connection is not nammed. Return the Node_Id of the newly
created connection if everything went right, else No_Node.

<pre class="example">     <b>function </b>Add_New_Connection
          (Loc           : Location;
           Name          : Node_Id;
           Comp_Impl     : Node_Id;
           Category      : Ocarina.Me_AADL.Connection_Type;
           Is_Refinement : Boolean := False;
           Is_Bidirect   : Boolean := False;
           Source        : Node_Id := No_Node;
           Destination   : Node_Id := No_Node;
           In_Modes      : Node_Id := No_Node)
          <b>return </b>Node_Id;
</pre>
   <p><strong>New_Connection</strong>: Create a new connection into a component implementation. 
Loc is the location of the connection in the parsed text. 
Name references an identifier which contains the name
of the connection, if any. Category is the type of the
connection. Is_Refinement indicates wether the connection is a
refinement or not. Source and Destination are the left and
right memebers of the connection. In_Modes contains the list of
the modes associated to the connection. Name can be No_Node, if
the connection is not nammed. Return the Node_Id of the newly
created connection if everything went right, else No_Node.

<pre class="example">     <b>function </b>New_Connection
          (Loc           : Location;
           Name          : Node_Id;
           Category      : Ocarina.Me_AADL.Connection_Type;
           Is_Refinement : Boolean := False;
           Is_Bidirect   : Boolean := False;
           Source        : Node_Id := No_Node;
           Destination   : Node_Id := No_Node;
           In_Modes      : Node_Id := No_Node)
          <b>return </b>Node_Id;
</pre>
   <h5 class="subsubsection">6.1.4.6 Ocarina.Builder.AADL.Components.Features</h5>

<p>The core API for the feature subclause of the component types and
the port group types.

   <p>This package defines the following subprograms:

   <p><strong>Add_Property_Association</strong>:

<pre class="example">     <b>function </b>Add_Property_Association
          (Feature              : Node_Id;
           Property_Association : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_New_Port_Spec</strong>:

<pre class="example">     <b>function </b>Add_New_Port_Spec
          (Loc               : Location;
           Name              : Node_Id;
           Container         : Node_Id;
           Is_In             : Boolean;
           Is_Out            : Boolean;
           Is_Data           : Boolean;
           Is_Event          : Boolean;
           Is_Refinement     : Boolean := False;
           Associated_Entity : Node_Id := No_Node)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Port_Group_Spec</strong>:

<pre class="example">     <b>function </b>Add_New_Port_Group_Spec
          (Loc           : Location;
           Name          : Node_Id;
           Container     : Node_Id;
           Is_Refinement : Boolean := False)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Feature_Group_Spec</strong>:

<pre class="example">     <b>function </b>Add_New_Feature_Group_Spec
          (Loc           : Location;
           Name          : Node_Id;
           Container     : Node_Id;
           Is_Refinement : Boolean := False)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Server_Subprogram</strong>:

<pre class="example">     <b>function </b>Add_New_Server_Subprogram
          (Loc           : Location;
           Name          : Node_Id;
           Container     : Node_Id;
           Is_Refinement : Boolean := False)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Data_Subprogram_Spec</strong>:

<pre class="example">     <b>function </b>Add_New_Data_Subprogram_Spec
          (Loc           : Location;
           Name          : Node_Id;
           Container     : Node_Id;
           Is_Refinement : Boolean := False)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Subcomponent_Access</strong>:

<pre class="example">     <b>function </b>Add_New_Subcomponent_Access
          (Loc           : Location;
           Name          : Node_Id;
           Container     : Node_Id;
           Is_Refinement : Boolean := False;
           Category      : Ocarina.Me_AADL.Component_Category;
           Is_Provided   : Boolean)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Parameter</strong>:

<pre class="example">     <b>function </b>Add_New_Parameter
          (Loc           : Location;
           Name          : Node_Id;
           Container     : Node_Id;
           Is_In         : Boolean := True;
           Is_Out        : Boolean := True;
           Is_Refinement : Boolean := False)
          <b>return </b>Node_Id;
</pre>
   <h5 class="subsubsection">6.1.4.7 Ocarina.Builder.AADL.Components.Flows</h5>

<p>This package defines the following subprograms:

   <p><strong>Add_Property_Association</strong>: Add a property association to the flow declaration. Flow must
reference a flow implementation or a flow
specification. Property_Association references the property
association. Return True if everything went right, else False.

<pre class="example">     <b>function </b>Add_Property_Association
          (Flow                 : Node_Id;
           Property_Association : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_New_Flow_Spec</strong>: Create a new flow specification inside a component type

<pre class="example">     <b>function </b>Add_New_Flow_Spec
          (Loc           : Location;
           Name          : Node_Id;
           Comp_Type     : Node_Id;
           Category      : Flow_Category;
           Source_Flow   : Node_Id;
           Sink_Flow     : Node_Id;
           Is_Refinement : Boolean := False)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Flow_Implementation</strong>: Create a new flow implementation inside a component
implementation

<pre class="example">     <b>function </b>Add_New_Flow_Implementation
          (Loc           : Location;
           Container     : Node_Id;
           Name          : Node_Id;
           Category      : Flow_Category;
           In_Modes      : Node_Id;
           Is_Refinement : Boolean;
           Source_Flow   : Node_Id;
           Sink_Flow     : Node_id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_End_To_End_Flow_Spec</strong>: Create a new end to end flow specification inside a component
implementation

<pre class="example">     <b>function </b>Add_New_End_To_End_Flow_Spec
          (Loc           : Location;
           Container     : Node_Id;
           Name          : Node_Id;
           In_Modes      : Node_Id;
           Is_Refinement : Boolean;
           Source_Flow   : Node_Id;
           Sink_Flow     : Node_id)
          <b>return </b>Node_Id;
</pre>
   <h5 class="subsubsection">6.1.4.8 Ocarina.Builder.AADL.Components.Modes</h5>

<p>This package provides functions to handle modes in the component
implementations.

   <p>This package defines the following subprograms:

   <p><strong>Add_Property_Association</strong>: Add a property association to the mode declaration or mode
transition. Mode must either reference a mode declaration or a
mode transition. Property_Association references the property
association. Return True if everything went right, else False.

<pre class="example">     <b>function </b>Add_Property_Association
          (Mode : Node_Id;
           Property_Association : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_New_Mode</strong>: Add a new mode declaration into a component implementation. Loc
is the location of the mode declaration in the parsed
text. Identifier references an identifier containing the name
of the mode. Component references the component
implementation. Is_Implicit is used by other parts of the
builder API, for "in modes" clauses. You should always keep it
False. Return a Node_Id referencing the newly created mode if
everything went right, else False.

<pre class="example">     <b>function </b>Add_New_Mode
          (Loc : Location;
           Identifier : Node_Id;
           Component : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Mode_Transition</strong>: Add a new empty mode transition into a component
implementation. Source, Destination, etc. of the mode
transition must be added manually after the node has been
created. Loc is the location of the mode transition in the
parsed text. Identifier references an identifier containing the
name of the mode. Component references the component
implementation. Return a Node_Id referencing the newly created
mode if everything went right, else False.

<pre class="example">     <b>function </b>Add_New_Mode_Transition
          (Loc : Location;
           Component : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Mode_Transition_Trigger</strong>:

<pre class="example">     <b>function </b>Add_New_Mode_Transition_Trigger
          (Loc : Locations.Location;
           Identifier : Types.Node_Id;
           Is_Self : Boolean;
           Is_Process<b>or </b>: Boolean)
          <b>return </b>Types.Node_Id;
</pre>
   <h5 class="subsubsection">6.1.4.9 Ocarina.Builder.AADL.Components.Subcomponents</h5>

<p>This package defines the following subprograms:

   <p><strong>Add_Property_Association</strong>: Add a property association to the subcomponent
declaration. Subcomponent must reference a Subcomponent
declaration. Property_Association references the property
association. Return True if everything went right, else False.

<pre class="example">     <b>function </b>Add_Property_Association
          (Subcomponent         : Node_Id;
           Property_Association : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_New_Subcomponent</strong>: Create and add a new subcomponent into a component
implementation. Loc is the location of the subcomponent in the
parsed text. Name references an identifier which contains the
name of the subcomponent. Comp_Impl references the component
implementation. Category is the type of the
subcomponent. Is_Refinement indicates wether the connection is
a refinement or not. In_Modes contains the list of the modes
associated to the connection. Return the Node_Id of the newly
created subcomponent if everything went right, else No_Node.

<pre class="example">     <b>function </b>Add_New_Subcomponent
          (Loc                 : Location;
           Name                : Node_Id;
           Comp_Impl           : Node_Id;
           Category            : Ocarina.ME_AADL.Component_Category;
           Is_Refinement       : Boolean := False;
           In_Modes            : Node_Id := No_Node;
           Prototypes_Bindings : List_Id := No_List)
          <b>return </b>Node_Id;
</pre>
   <h5 class="subsubsection">6.1.4.10 Ocarina.Builder.AADL.Components.Subprogram_Calls</h5>

<p>This package defines the following subprograms:

   <p><strong>Add_Property_Association</strong>: Add a property association to the subprogram
call. Subprogram_Call must reference a subprogram call (not a
call sequence). Property_Association references the property
association. Return True if everything went right, else False.

<pre class="example">     <b>function </b>Add_Property_Association
          (Subprogram_C<b>all </b>     : Node_Id;
           Property_Association : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_Subprogram_Call</strong>: Add a subprogram call to the subprogram call
sequence. Subprogram_Call must reference a subprogram call (not
a call sequence). Call_Sequence references the subprogram call
sequence. Return True if everything went right, else False.

<pre class="example">     <b>function </b>Add_Subprogram_C<b>all </b>     (Call_Sequence   : Node_Id;
           Subprogram_C<b>all </b>: Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_New_Subprogram_Call</strong>: Create and add a new subprogram call into a subprogram call
sequence. Loc is the location of the call sequence in the
parsed text. Name references an identifier which contains the
name of the subprogram call. Call_Sequence references the
subprogram call sequence that contains the subprogram call. 
The function return the Node_Id of the newly created subprogram
call if everything went right, else No_Node.

<pre class="example">     <b>function </b>Add_New_Subprogram_C<b>all </b>     (Loc           : Location;
           Name          : Node_Id;
           Call_Sequence : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Subprogram_Call_Sequence</strong>: Create and add a new subprogram call sequence into a component
implementation. Loc is the location of the call sequence in the
parsed text. Name references an identifier which contains the
name of the call sequence, if any. Comp_Impl references the
component implementation.  In_Modes contains the list of the
modes associated to the connection. Name can be No_Node, if the
sequence is not nammed. Subprogram calls Return the Node_Id of
the newly created call sequence if everything went right, else
No_Node.

<pre class="example">     <b>function </b>Add_New_Subprogram_Call_Sequence
          (Loc       : Location;
           Name      : Node_Id;
           Comp_Impl : Node_Id;
           In_Modes  : Node_Id := No_Node)
          <b>return </b>Node_Id;
</pre>
   <h5 class="subsubsection">6.1.4.11 Ocarina.Builder.AADL.Namespaces</h5>

<p>This package defines the following subprograms:

   <p><strong>Add_Declaration</strong>: Insert any component, property_set, package or port_group into
the AADL specification. Namespace must reference the node
created with Initialize_Unnamed_Namespace or a package
specification. Return True if the element was correctly
inserted, else False

<pre class="example">     <b>function </b>Add_Declaration
          (Namespace : Types.Node_Id;
           Element : Types.Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Initialize_Unnamed_Namespace</strong>: Create the AADL specification node, which corresponds to the
top level of the AADL description. This function must be
invoked first, as all the other elements of the description
will be added to this one. Loc is the location of the AADL
specification in the parsed text. Return a reference to the
newly created node if everything went right, else False.

<pre class="example">     <b>function </b>Initialize_Unnamed_Namespace
          (Loc : Locations.Location)
          <b>return </b>Types.Node_Id;
</pre>
   <p><strong>Add_New_Package</strong>: Checks if a package of that name already exists. If so, return
this one, else create a new one and return it. Loc is the
location of the package specification in the parsed
text. Pack_Name is a Node_Id referencing an identifier which
contains the name of the package. Namespace must reference the
top level AADL specification node.

<pre class="example">     <b>function </b>Add_New_Package
          (Loc : Locations.Location;
           Pack_Name : Types.Node_Id;
           Namespace : Types.Node_Id)
          <b>return </b>Types.Node_Id;
</pre>
   <p><strong>Add_New_Package_Name</strong>: Add a property association to the list of the package
properties, without checking for homonyms or whatever. This
function should be only used by other functions of the core
API. Namespace must reference a package specification. Return
True if the property was added, else False.

<pre class="example">     <b>function </b>Add_New_Package_Name
          (Loc            : Locations.Location;
           Identifiers    : Types.List_Id)
          <b>return </b>Types.Node_Id;
</pre>
   <p><strong>Add_Property_Association</strong>: Add a property association to the list of the package
properties, without checking for homonyms or whatever. This
function should be only used by other functions of the core
API. Namespace must reference a package specification. Return
True if the property was added, else False.

<pre class="example">     <b>function </b>Add_Property_Association
          (Pack : Types.Node_Id;
           Property_Association : Types.Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Add_New_Name_Visibility_Declaration</strong>: Create the name visibility declaration node to the list of
the package declarations, without checking.

<pre class="example">     <b>function </b>Add_New_Name_Visibility_Declaration
          (Loc         : Locations.Location;
           Namespace   : Types.Node_Id;
           List_Items  : Types.List_Id;
           Is_Private  : Boolean := False)
          <b>return </b>Types.Node_Id;
</pre>
   <p><strong>Add_New_Import_Declaration</strong>: Create the import node to the list of the name visibility declarations,
without checking.

<pre class="example">     <b>function </b>Add_New_Import_Declaration
          (Loc         : Locations.Location;
           Namespace   : Types.Node_Id;
           List_Items  : Types.List_Id;
           Is_Private  : Boolean := False)
          <b>return </b>Types.Node_Id;
</pre>
   <p><strong>Add_New_Alias_Declaration</strong>: Create the alias node to the list of the name visibility declarations,
without checking.

<pre class="example">     <b>function </b>Add_New_Alias_Declaration
          (Loc            : Locations.Location;
           Namespace      : Types.Node_Id;
           Identifier     : Types.Node_Id;
           Package_Name   : Types.Node_Id;
           Classifier_Ref : Types.Node_Id;
           Entity_Cat     : Ocarina.ME_AADL.Entity_Category;
           Component_Cat  : Ocarina.ME_AADL.Component_Category;
           Is_All         : Boolean := False;
           Is_Private     : Boolean := False)
          <b>return </b>Types.Node_Id;
</pre>
   <h5 class="subsubsection">6.1.4.12 Ocarina.Builder.AADL.Properties</h5>

<p>This package defines the following subprograms:

   <p><strong>Add_New_Property_Set</strong>: Either Single_Value /= No_Node and Mulitple_Values = No_Node,
then we have a single valued constant; or Single_Value =
No_Node, then we have a muli valued constant

<pre class="example">     <b>function </b>Add_New_Property_Set
          (Loc       : Location;
           Name      : Node_Id;
           Namespace : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Property_Constant_Declaration</strong>: Either Single_Value /= No_Node and Mulitple_Values = No_Node,
then we have a single valued constant; or Single_Value =
No_Node, then we have a muli valued constant

<pre class="example">     <b>function </b>Add_New_Property_Constant_Declaration
          (Loc             : Location;
           Name            : Node_Id;
           Property_Set    : Node_Id;
           Constant_Type   : Node_Id;
           Unit_Identifier : Node_Id;
           Single_Value    : Node_Id;
           Multiple_Values : List_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Property_Type_Declaration</strong>: Either Applies_To_All is set to True and Applies_To is empty,
or Applies_To_All is False and Applies_To is not empty

<pre class="example">     <b>function </b>Add_New_Property_Type_Declaration
          (Loc             : Location;
           Name            : Node_Id;
           Property_Set    : Node_Id;
           Type_Designat<b>or </b>: Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Property_Definition_Declaration</strong>: Either Applies_To_All is set to True and Applies_To is empty,
or Applies_To_All is False and Applies_To is not empty

<pre class="example">     <b>function </b>Add_New_Property_Definition_Declaration
          (Loc                     : Location;
           Name                    : Node_Id;
           Property_Set            : Node_Id;
           Is_Inherit              : Boolean;
           Is_Access               : Boolean;
           Single_Default_Value    : Node_Id;
           Multiple_Default_Value  : List_Id;
           Property_Name_Type      : Node_Id;
           Property_Type_Is_A_List : Boolean;
           Applies_To_All          : Boolean;
           Applies_To              : List_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Property_Association</strong>: If Check_For_Conflicts is set to True, then the function checks
whether there is a property association of that name
already. If override is set to True and there is a conflict,
then it is overridden by the new association. Else the new
association is ignored. If Check_For_Conflicts is set to False,
then the value of Override is ignored.

<pre class="example">     <b>function </b>Add_New_Property_Association
          (Loc                 : Location;
           Name                : Node_Id;
           Property_Name       : Node_Id;
           Container           : Node_Id;
           In_Binding          : Node_Id;
           In_Modes            : Node_Id;
           Property_Value      : Node_Id;
           Is_Constant         : Boolean;
           Is_Access           : Boolean;
           Is_Additive         : Boolean;
           Applies_To          : List_Id;
           Check_For_Conflicts : Boolean := False;
           Override            : Boolean := False)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Add_New_Contained_Element_Path</strong>:

<pre class="example">     <b>function </b>Add_New_Contained_Element_Path
          (Loc             : Location;
           Container       : Node_Id;
           Applies_To_Elts : List_Id;
           Annex_Path : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <h5 class="subsubsection">6.1.4.13 Ocarina.Analyzer.AADL.Finder</h5>

<p>This package provides functions to search nodes in the abstract
tree. The functions return No_Node if nothing was found.

   <p>This package defines the following subprograms:

   <p><strong>Select_Nodes</strong>: Build a list (chained using the accessor Next_Entity) from
Decl_List and appends it to Last_Node. This list will contain
the nodes whose kinds correspond to Kinds.

<pre class="example">     <b>procedure </b>Select_Nodes
          (Decl_List  :        List_Id;
           Kinds      :        Node_Kind_Array;
           First_Node : <b>in </b><b>out </b>Node_Id;
           Last_Node  : <b>in </b><b>out </b>Node_Id);
</pre>
   <p><strong>Find_Property_Entity</strong>: Find a property entity (type, name or constant). If
Property_Set_Identifier is No_Node and the current scope is the
one of a property set, try to find the property in it. Finally,
look for the implicit property sets (AADL_Project and
AADL_Properties).

<pre class="example">     <b>function </b>Find_Property_Entity
          (Root                    : Node_Id;
           Property_Set_Identifier : Node_Id;
           Property_Identifier     : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_Component_Classifier</strong>: Same as above, but find a component classifier

<pre class="example">     <b>function </b>Find_Component_Classifier
          (Root                 : Node_Id;
           Package_Identifier   : Node_Id;
           Component_Identifier : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_Port_Group_Classifier</strong>: Same as above, but find a port group

<pre class="example">     <b>function </b>Find_Port_Group_Classifier
          (Root                  : Node_Id;
           Package_Identifier    : Node_Id;
           Port_Group_Identifier : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_Feature</strong>: Find a feature in a component type or implementation

<pre class="example">     <b>function </b>Find_Feature
          (Component          : Node_Id;
           Feature_Identifier : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_Mode</strong>: Same as above, but find a mode

<pre class="example">     <b>function </b>Find_Mode
          (Component       : Node_Id;
           Mode_Identifier : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_Subcomponent</strong>: Find a subcomponent in a component implementation. If In_Modes
is specified, return the subcomponent that are set in the
given modes.

<pre class="example">     <b>function </b>Find_Subcomponent
          (Component               : Node_Id;
           Subcomponent_Identifier : Node_Id;
           In_Modes                : Node_Id := No_Node)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_Subprogram_Call</strong>: Same as above but find a subprogram call

<pre class="example">     <b>function </b>Find_Subprogram_C<b>all </b>     (Component       : Node_Id;
           Call_Identifier : Node_Id;
           In_Modes        : Node_Id := No_Node)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_Connection</strong>: Same as above but find a connection

<pre class="example">     <b>function </b>Find_Connection
          (Component             : Node_Id;
           Connection_Identifier : Node_Id;
           In_Modes              : Node_Id := No_Node)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_Flow_Spec</strong>: Find a flow in a component type or implementation

<pre class="example">     <b>function </b>Find_Flow_Spec
          (Component       : Node_Id;
           Flow_Identifier : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_Subclause</strong>: Same as above but find a subclause

<pre class="example">     <b>function </b>Find_Subcla<b>use </b>     (Component  : Node_Id;
           Identifier : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_All_Declarations</strong>: Returns the first node of a list of declarations corresponding
to the Kinds requested. Following nodes are accessed through
the Next_Entity accessor. If no Kinds are requested, then
return all the declarations found. If the Namespace is not
given, search the declaration in the whole AADL specification
declarations and its namespaces. Otherwise, search the
declaration in the given namespace.

<pre class="example">     <b>function </b>Find_All_Declarations
          (Root      : Node_Id;
           Kinds     : Node_Kind_Array;
           Namespace : Node_Id := No_Node)
          <b>return </b>Node_List;
</pre>
   <p><strong>Find_All_Component_Types</strong>: Return the first component type found in the Namespace. If
Namespace is No_Node, then return the first component type
declaration in the whole AADL specification. Following
declarations are accessed using the Next_Entity accessor.

<pre class="example">     <b>function </b>Find_All_Component_Types
          (Root      : Node_Id;
           Namespace : Node_Id := No_Node)
          <b>return </b>Node_List;
</pre>
   <p><strong>Find_All_Root_Systems</strong>: Return all systems implementations whose component type do not
have any feature. Those systems correspond to the roots of the
instantiated architecture.

<pre class="example">     <b>function </b>Find_All_Root_Systems (Root : Node_Id) <b>return </b>Node_List;
</pre>
   <p><strong>Find_All_Subclauses</strong>: General function that returns the first node of a list of
subclauses corresponding to the Kinds requested. Following
nodes are accessed through the Next_Entity accessor.

<pre class="example">     <b>function </b>Find_All_Subclauses
          (AADL_Declaration : Node_Id;
           Kinds            : Node_Kind_Array)
          <b>return </b>Node_List;
</pre>
   <p><strong>Find_All_Features</strong>: Applicable to component types and implementations, and port
group types.

<pre class="example">     <b>function </b>Find_All_Features
          (AADL_Declaration : Node_Id)
          <b>return </b>Node_List;
</pre>
   <p><strong>Find_All_Subclause_Declarations_Except_Properties</strong>: Applicable to component types and implementations, and port
group types.

<pre class="example">     <b>function </b>Find_All_Subclause_Declarations_Except_Properties
          (AADL_Declaration : Node_Id)
          <b>return </b>Node_List;
</pre>
   <p><strong>Find_All_Property_Associations</strong>: Applicable to component types and implementations, and port
group types.

<pre class="example">     <b>function </b>Find_All_Property_Associations
          (AADL_Declaration : Node_Id)
          <b>return </b>Node_List;
</pre>
   <p><strong>Find_Property_Association</strong>: Find the property association named
Property_Association_Name. Return No_Node if nothing was found.

<pre class="example">     <b>function </b>Find_Property_Association
          (AADL_Declaration          : Node_Id;
           Property_Association_Name : Name_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_Property_Enumeration</strong>: The kind of Package_Container is K_Package_Specification,
the kind of Node is K_Identifier or K_ENtity_Reference,
return True if the Node is 'with' in Package_Container
'with' declarations.

<pre class="example">     <b>function </b>Find_Property_Enumeration
          (Root               : Node_Id;
           Container          : Node_Id;
           Property_Container : Node_Id;
           Default_Value      : Node_Id;
           Designat<b>or </b>        : Node_Id)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Find_In_Import_Declaration</strong>: The kind of Package_Container is K_Package_Specification,
the kind of Node is K_Identifier or K_ENtity_Reference,
return True if the Node is 'with' in Package_Container
'with' declarations.

<pre class="example">     <b>function </b>Find_In_Import_Declaration
          (Package_Container : Node_Id;
           Node              : Node_Id)
          <b>return </b>Boolean;
</pre>
   <h5 class="subsubsection">6.1.4.14 Ocarina.Analyzer.AADL.Queries</h5>

<p>This package contains routines that are used to get several
information from the AADL tree.

   <p>This package defines the following subprograms:

   <p><strong>Is_An_Extension</strong>: Returns True if Component is an extension of Ancestor, whether
by the keyword 'extends' or because Ancestor is a corresponding
component type.

<pre class="example">     <b>function </b>Is_An_Extension
          (Component : Node_Id;
           Ancest<b>or </b> : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Needed_By</strong>: Return True iff N is needed by Entity (for example Entity has a
subcompnent of type N). It also return True if N is needed
indirectly by Entity (through another intermediate need). In
order for this function to work fine, the AADL tree must have
been expanded. However, since it acts only on the AADL syntax
tree, this function is put in this package. 
NOTE: If N is a property *declaration* node, the result will be
True reguardless the actual need of Entity to N.

<pre class="example">     <b>function </b>Needed_By (N : Node_Id; Entity : Node_Id) <b>return </b>Boolean;
</pre>
   <p><strong>Property_Can_Apply_To_Entity</strong>: Return True if the property association Property can be applied
to Entity. Otherwise, return False. Beware that this function
performs exact verification; a property cannot apply to a
package.

<pre class="example">     <b>function </b>Property_Can_Apply_To_Entity
          (Property : Node_Id;
           Entity   : Node_Id)
          <b>return </b>Boolean;
</pre>
   <p><strong>Is_Defined_Property</strong>: Return True if the property named 'Name' is defined for the
AADL entity 'Entity'. If 'In_Mode' is a valid name, consider
only the property defined for the given mode.

<pre class="example">     <b>function </b>Is_Defined_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Boolean;
</pre>
   <p><strong>Is_Defined_String_Property</strong>: Return True if the aadlstring property named 'Name' is defined
for the AADL entity 'Entity'. If 'In_Mode' is a valid name,
consider only the property defined for the given mode.

<pre class="example">     <b>function </b>Is_Defined_String_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Boolean;
</pre>
   <p><strong>Is_Defined_Integer_Property</strong>: Return True if the aadlinteger property named 'Name' is defined
for the AADL entity 'Entity'. If 'In_Mode' is a valid name,
consider only the property defined for the given mode.

<pre class="example">     <b>function </b>Is_Defined_Integer_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Boolean;
</pre>
   <p><strong>Is_Defined_Boolean_Property</strong>: Return True if the aadlboolean property named 'Name' is defined
for the AADL entity 'Entity'. If 'In_Mode' is a valid name,
consider only the property defined for the given mode.

<pre class="example">     <b>function </b>Is_Defined_Boolean_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Boolean;
</pre>
   <p><strong>Is_Defined_Float_Property</strong>: Return True if the aadlreal property named 'Name' is defined
for the AADL entity 'Entity'. If 'In_Mode' is a valid name,
consider only the property defined for the given mode.

<pre class="example">     <b>function </b>Is_Defined_Float_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Boolean;
</pre>
   <p><strong>Is_Defined_Reference_Property</strong>: Return True if the component reference property named 'Name' is
defined for the AADL entity 'Entity'. If 'In_Mode' is a valid
name, consider only the property defined for the given mode.

<pre class="example">     <b>function </b>Is_Defined_Reference_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Boolean;
</pre>
   <p><strong>Is_Defined_Classifier_Property</strong>: Return True if the component classifier property named 'Name' is
defined for the AADL entity 'Entity'. If 'In_Mode' is a valid
name, consider only the property defined for the given mode.

<pre class="example">     <b>function </b>Is_Defined_Classifier_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Boolean;
</pre>
   <p><strong>Is_Defined_Range_Property</strong>: Return True if the component range property named 'Name' is
defined for the AADL entity 'Entity'. If 'In_Mode' is a valid
name, consider only the property defined for the given mode.

<pre class="example">     <b>function </b>Is_Defined_Range_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Boolean;
</pre>
   <p><strong>Is_Defined_List_Property</strong>: Return True if the 'list of XXX' property named 'Name' is
defined for the AADL entity 'Entity'. If 'In_Mode' is a valid
name, consider only the property defined for the given mode.

<pre class="example">     <b>function </b>Is_Defined_List_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Boolean;
</pre>
   <p><strong>Is_Defined_Enumeration_Property</strong>: Return True if the enumeration property named 'Name' is defined
for the AADL entity 'Entity'. If 'In_Mode' is a valid name,
consider only the property defined for the given mode.

<pre class="example">     <b>function </b>Is_Defined_Enumeration_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Boolean;
</pre>
   <p><strong>Get_Property_Association</strong>: Return the property association node corresponding to Name. If
the propoerty designed by name is not present for Entity,
return No_Node. If 'In_Mode' is a valid name, consider only
the property defined for the given mode.

<pre class="example">     <b>function </b>Get_Property_Association
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Get_Value_Of_Property_Association</strong>: Return the value of the property association named 'Name' if it
is defined defined for 'Entity'.  Otherwise, return No_Node. If
'In_Mode' is a valid name, consider only the property defined
for the given mode.

<pre class="example">     <b>function </b>Get_Value_Of_Property_Association
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Get_String_Property</strong>: Return the value of the aadlstring property association named
'Name' if it is defined defined for 'Entity'.  Otherwise,
return "". If 'In_Mode' is a valid name, consider only the
property defined for the given mode.

<pre class="example">     <b>function </b>Get_String_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>String;
</pre>
   <p><strong>Get_String_Property</strong>: Return the value of the aadlstring property association named
'Name' if it is defined defined for 'Entity'.  Otherwise,
return No_Name. If 'In_Mode' is a valid name, consider only
the property defined for the given mode.

<pre class="example">     <b>function </b>Get_String_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Name_Id;
</pre>
   <p><strong>Get_Integer_Property</strong>: Return the value of the aadlinteger property association named
'Name' if it is defined defined for 'Entity'.  Otherwise,
return 0. If 'In_Mode' is a valid name, consider only the
property defined for the given mode.

<pre class="example">     <b>function </b>Get_Integer_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Unsigned_Long_Long;
</pre>
   <p><strong>Get_Float_Property</strong>: Return the value of the aadlreal property association named
'Name' if it is defined defined for 'Entity'.  Otherwise,
return 0.0. If 'In_Mode' is a valid name, consider only the
property defined for the given mode.

<pre class="example">     <b>function </b>Get_Float_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Long_Long_Float;
</pre>
   <p><strong>Get_Boolean_Property</strong>: Return the value of the aadlboolean property association named
'Name' if it is defined defined for 'Entity'.  Otherwise,
return False. If 'In_Mode' is a valid name, consider only the
property defined for the given mode.

<pre class="example">     <b>function </b>Get_Boolean_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Boolean;
</pre>
   <p><strong>Get_Reference_Property</strong>: Return the value of the component reference property
association named 'Name' if it is defined for 'Entity'. 
Otherwise, return No_Node. If 'In_Mode' is a valid name,
consider only the property defined for the given mode.

<pre class="example">     <b>function </b>Get_Reference_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Get_Classifier_Property</strong>: Return the value of the component classifier property
association named 'Name' if it is defined for 'Entity'. 
Otherwise, return No_Node. If 'In_Mode' is a valid name,
consider only the property defined for the given mode.

<pre class="example">     <b>function </b>Get_Classifier_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Get_List_Property</strong>: Return the value of the 'list of XXX' property association
named 'Name' if it is defined for 'Entity'. The returned list
is a Node_Container list. Otherwise, return No_List. If
'In_Mode' is a valid name, consider only the property defined
for the given mode.

<pre class="example">     <b>function </b>Get_List_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>List_Id;
</pre>
   <p><strong>Get_Range_Property</strong>: Return the values of the range property association named
'Name' if it is defined for 'Entity'.  Otherwise, return
No_List. If 'In_Mode' is a valid name, consider only the
property defined for the given mode.

<pre class="example">     <b>function </b>Get_Range_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Node_Id;
</pre>
   <p><strong>Get_Enumeration_Property</strong>: Return the value of the enumeration property association named
'Name' if it is defined defined for 'Entity'. Otherwise, return
"". If 'In_Mode' is a valid name, consider only the property
defined for the given mode.

<pre class="example">     <b>function </b>Get_Enumeration_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>String;
</pre>
   <p><strong>Get_Enumeration_Property</strong>: Return the value of the enumeration property association named
'Name' if it is defined defined for 'Entity'. Otherwise, return
No_Name. If 'In_Mode' is a valid name, consider only the
property defined for the given mode.

<pre class="example">     <b>function </b>Get_Enumeration_Property
          (Entity  : Node_Id;
           Name    : Name_Id;
           In_Mode : Name_Id := No_Name)
          <b>return </b>Name_Id;
</pre>
   <p><strong>Compute_Property_Value</strong>: Compute the value of a property value and return a Node_Id
containing this value. This value does not contain any
reference (value ()).

<pre class="example">     <b>function </b>Compute_Property_Value (Property_Value : Node_Id) <b>return </b>Node_Id;
</pre>
   </body></html>

